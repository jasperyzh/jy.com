import { a as createComponent, b as renderTemplate, r as renderComponent, m as maybeRenderHead } from './astro/server_BuftSjIy.mjs';
import 'kleur/colors';
import { a as $$BaseLayout } from './BaseLayout_DEWwRiOq.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a, _b;
const $$250402UndoTechnique = createComponent(($$result, $$props, $$slots) => {
  return renderTemplate(_b || (_b = __template(["", ' <style>\n  /* \nbody {\n    font-family: sans-serif;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 20px;\n    background-color: #f4f4f4;\n} */\n\n  h1 {\n    color: #333;\n  }\n\n  .controls {\n    margin-bottom: 15px;\n  }\n\n  button {\n    padding: 8px 15px;\n    margin: 0 5px;\n    font-size: 1em;\n    cursor: pointer;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    background-color: #e7e7e7;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background-color: #f0f0f0;\n  }\n\n  button:hover:not(:disabled) {\n    background-color: #dcdcdc;\n  }\n\n  #drawingCanvas {\n    border: 2px solid #333;\n    background-color: #fff;\n    cursor: crosshair;\n    touch-action: none; /* Prevent default touch actions like scrolling */\n  }\n\n  p {\n    margin-top: 15px;\n    color: #555;\n  }\n</style> <script>\n  // 3. JavaScript Undo Stack (undoStack.js):\n  function createUndoStack() {\n    const past = []; // Actions that have been done and can be undone\n    const future = []; // Actions that have been undone and can be redone\n\n    return {\n      /**\n       * Pushes a new action onto the undo stack.\n       * Executes the doFn immediately.\n       * Clears the redo stack.\n       * @param {Function} doFn - The function to execute to perform the action.\n       * @param {Function} undoFn - The function to execute to undo the action.\n       * @param {...any} withArgumentsToClone - Arguments to be deep-cloned and passed to doFn and undoFn.\n       */\n      push(doFn, undoFn, ...withArgumentsToClone) {\n        // Clone arguments to prevent issues with mutable objects and closures\n        const clonedArgs = structuredClone(withArgumentsToClone);\n\n        const action = {\n          // Wrapper functions to ensure the cloned arguments are used\n          doWithData() {\n            doFn(...clonedArgs);\n          },\n          undoWithData() {\n            undoFn(...clonedArgs);\n          },\n        };\n\n        // Execute the action immediately\n        action.doWithData();\n\n        // Add the action to the past (undo stack)\n        past.push(action);\n\n        // Adding a new action clears the future (redo stack)\n        if (future.length > 0) {\n          console.log("Clearing redo stack because a new action was pushed.");\n          future.length = 0;\n        }\n      },\n\n      /**\n       * Undoes the last action.\n       * Moves the action from the past stack to the future stack.\n       */\n      undo() {\n        const action = past.pop();\n        if (action) {\n          console.log("Undoing action...");\n          action.undoWithData();\n          future.unshift(action); // Add to the beginning of the redo stack\n        } else {\n          console.log("Nothing to undo.");\n        }\n      },\n\n      /**\n       * Redoes the last undone action.\n       * Moves the action from the future stack back to the past stack.\n       */\n      redo() {\n        const action = future.shift(); // Remove from the beginning of the redo stack\n        if (action) {\n          console.log("Redoing action...");\n          action.doWithData();\n          past.push(action); // Add back to the end of the undo stack\n        } else {\n          console.log("Nothing to redo.");\n        }\n      },\n\n      /**\n       * Checks if there are actions that can be undone.\n       * @returns {boolean} True if undo is available, false otherwise.\n       */\n      get undoAvailable() {\n        return past.length > 0;\n      },\n\n      /**\n       * Checks if there are actions that can be redone.\n       * @returns {boolean} True if redo is available, false otherwise.\n       */\n      get redoAvailable() {\n        return future.length > 0;\n      },\n\n      /**\n       * Clears both the undo and redo stacks.\n       * @returns {boolean} True.\n       */\n      clear() {\n        console.log("Clearing undo/redo history.");\n        past.length = 0;\n        future.length = 0;\n        return true;\n      },\n    };\n  }\n\n  // If using modules (though not strictly required for this simple example)\n  // export { createUndoStack };\n<\/script> <script>\n  // 4. JavaScript Application Logic (script.js):\n\n  document.addEventListener("DOMContentLoaded", () => {\n    const canvas = document.getElementById("drawingCanvas");\n    const ctx = canvas.getContext("2d");\n    const undoBtn = document.getElementById("undoBtn");\n    const redoBtn = document.getElementById("redoBtn");\n    const clearBtn = document.getElementById("clearBtn");\n\n    // --- State ---\n    let isDrawing = false;\n    let currentStroke = []; // Array of points {x, y} for the stroke currently being drawn\n    let strokes = []; // Array of completed strokes (each stroke is an array of points)\n    const undoStack = createUndoStack();\n\n    // --- Canvas Setup ---\n    ctx.lineWidth = 3;\n    ctx.lineCap = "round";\n    ctx.strokeStyle = "#000000";\n\n    // --- Drawing Functions ---\n    function getMousePos(evt) {\n      const rect = canvas.getBoundingClientRect();\n      // Adjust for touch events\n      const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;\n      const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;\n      return {\n        x: clientX - rect.left,\n        y: clientY - rect.top,\n      };\n    }\n\n    function startDrawing(e) {\n      isDrawing = true;\n      currentStroke = []; // Start a new stroke\n      const pos = getMousePos(e);\n      currentStroke.push(pos);\n      // Draw the starting point immediately (optional, good for dots)\n      // ctx.beginPath();\n      // ctx.moveTo(pos.x, pos.y);\n      // ctx.lineTo(pos.x, pos.y); // Draw a tiny line segment or dot\n      // ctx.stroke();\n    }\n\n    function draw(e) {\n      if (!isDrawing) return;\n      const pos = getMousePos(e);\n\n      // Draw line segment visually as mouse moves\n      ctx.beginPath();\n      // Use the last point in currentStroke as the start\n      const lastPoint = currentStroke[currentStroke.length - 1];\n      ctx.moveTo(lastPoint.x, lastPoint.y);\n      ctx.lineTo(pos.x, pos.y);\n      ctx.stroke();\n\n      // Add point to the current stroke data\n      currentStroke.push(pos);\n      e.preventDefault(); // Prevent scrolling on touch devices\n    }\n\n    function stopDrawing() {\n      if (!isDrawing) return;\n      isDrawing = false;\n\n      // Only save if the stroke has more than one point (or your desired threshold)\n      if (currentStroke.length > 1) {\n        console.log(\n          `Stroke finished with ${currentStroke.length} points. Pushing to undo stack.`\n        );\n        // --- UNDO STACK INTEGRATION ---\n        // We need functions to add and remove *this specific stroke*\n        const strokeToAdd = currentStroke; // Keep reference before resetting\n\n        const addStrokeAction = (strokeData) => {\n          console.log("Executing: Add Stroke");\n          strokes.push(strokeData);\n          redrawCanvas(); // Redraw everything including the new stroke\n          updateButtonStates();\n        };\n\n        const removeStrokeAction = (strokeData) => {\n          console.log("Executing: Remove Stroke");\n          // In a more complex scenario, you might search for strokeData,\n          // but here we assume it\'s always the last one added by the corresponding \'do\'.\n          const removed = strokes.pop();\n          // Optional check: console.log("Removed stroke matches expected?", removed === strokeData); // Note: This won\'t work due to cloning\n          redrawCanvas(); // Redraw without the removed stroke\n          updateButtonStates();\n        };\n\n        // Push the actions and the stroke data (which will be cloned)\n        // The push method executes addStrokeAction immediately.\n        undoStack.push(addStrokeAction, removeStrokeAction, strokeToAdd);\n        // We don\'t call addStrokeAction here, push does it!\n      } else {\n        console.log("Stroke too short, not saving.");\n      }\n\n      // Reset current stroke for the next drawing action\n      currentStroke = [];\n      // No need to redraw here, push already triggered redraw via addStrokeAction\n      updateButtonStates(); // Update buttons after potential push\n    }\n\n    function redrawCanvas() {\n      console.log(`Redrawing canvas with ${strokes.length} strokes.`);\n      // Clear the entire canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Redraw all committed strokes\n      strokes.forEach((stroke) => {\n        if (stroke.length < 2) return; // Need at least two points to draw a line\n\n        ctx.beginPath();\n        ctx.moveTo(stroke[0].x, stroke[0].y);\n        for (let i = 1; i < stroke.length; i++) {\n          ctx.lineTo(stroke[i].x, stroke[i].y);\n        }\n        ctx.stroke();\n      });\n    }\n\n    // --- UI Update Function ---\n    function updateButtonStates() {\n      undoBtn.disabled = !undoStack.undoAvailable;\n      redoBtn.disabled = !undoStack.redoAvailable;\n      console.log(\n        `UI Update: Can Undo: ${undoStack.undoAvailable}, Can Redo: ${undoStack.redoAvailable}`\n      );\n    }\n\n    // --- Clear Functionality ---\n    function clearAll() {\n      strokes = []; // Clear the drawing data\n      undoStack.clear(); // Clear the history\n      redrawCanvas(); // Clear the visual canvas\n      updateButtonStates(); // Update buttons\n    }\n\n    // --- Event Listeners ---\n    // Mouse events\n    canvas.addEventListener("mousedown", startDrawing);\n    canvas.addEventListener("mousemove", draw);\n    canvas.addEventListener("mouseup", stopDrawing);\n    canvas.addEventListener("mouseout", stopDrawing); // Stop drawing if mouse leaves canvas\n\n    // Touch events\n    canvas.addEventListener("touchstart", startDrawing);\n    canvas.addEventListener("touchmove", draw);\n    canvas.addEventListener("touchend", stopDrawing);\n    canvas.addEventListener("touchcancel", stopDrawing); // Handle interruption\n\n    undoBtn.addEventListener("click", () => {\n      undoStack.undo();\n      // Note: The undoFn (removeStrokeAction) calls redraw and update buttons\n    });\n\n    redoBtn.addEventListener("click", () => {\n      undoStack.redo();\n      // Note: The doFn (addStrokeAction) calls redraw and update buttons\n    });\n\n    clearBtn.addEventListener("click", clearAll);\n\n    // --- Initial State ---\n    updateButtonStates(); // Set initial button states\n  });\n<\/script>'], ["", ' <style>\n  /* \nbody {\n    font-family: sans-serif;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 20px;\n    background-color: #f4f4f4;\n} */\n\n  h1 {\n    color: #333;\n  }\n\n  .controls {\n    margin-bottom: 15px;\n  }\n\n  button {\n    padding: 8px 15px;\n    margin: 0 5px;\n    font-size: 1em;\n    cursor: pointer;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    background-color: #e7e7e7;\n  }\n\n  button:disabled {\n    opacity: 0.5;\n    cursor: not-allowed;\n    background-color: #f0f0f0;\n  }\n\n  button:hover:not(:disabled) {\n    background-color: #dcdcdc;\n  }\n\n  #drawingCanvas {\n    border: 2px solid #333;\n    background-color: #fff;\n    cursor: crosshair;\n    touch-action: none; /* Prevent default touch actions like scrolling */\n  }\n\n  p {\n    margin-top: 15px;\n    color: #555;\n  }\n</style> <script>\n  // 3. JavaScript Undo Stack (undoStack.js):\n  function createUndoStack() {\n    const past = []; // Actions that have been done and can be undone\n    const future = []; // Actions that have been undone and can be redone\n\n    return {\n      /**\n       * Pushes a new action onto the undo stack.\n       * Executes the doFn immediately.\n       * Clears the redo stack.\n       * @param {Function} doFn - The function to execute to perform the action.\n       * @param {Function} undoFn - The function to execute to undo the action.\n       * @param {...any} withArgumentsToClone - Arguments to be deep-cloned and passed to doFn and undoFn.\n       */\n      push(doFn, undoFn, ...withArgumentsToClone) {\n        // Clone arguments to prevent issues with mutable objects and closures\n        const clonedArgs = structuredClone(withArgumentsToClone);\n\n        const action = {\n          // Wrapper functions to ensure the cloned arguments are used\n          doWithData() {\n            doFn(...clonedArgs);\n          },\n          undoWithData() {\n            undoFn(...clonedArgs);\n          },\n        };\n\n        // Execute the action immediately\n        action.doWithData();\n\n        // Add the action to the past (undo stack)\n        past.push(action);\n\n        // Adding a new action clears the future (redo stack)\n        if (future.length > 0) {\n          console.log("Clearing redo stack because a new action was pushed.");\n          future.length = 0;\n        }\n      },\n\n      /**\n       * Undoes the last action.\n       * Moves the action from the past stack to the future stack.\n       */\n      undo() {\n        const action = past.pop();\n        if (action) {\n          console.log("Undoing action...");\n          action.undoWithData();\n          future.unshift(action); // Add to the beginning of the redo stack\n        } else {\n          console.log("Nothing to undo.");\n        }\n      },\n\n      /**\n       * Redoes the last undone action.\n       * Moves the action from the future stack back to the past stack.\n       */\n      redo() {\n        const action = future.shift(); // Remove from the beginning of the redo stack\n        if (action) {\n          console.log("Redoing action...");\n          action.doWithData();\n          past.push(action); // Add back to the end of the undo stack\n        } else {\n          console.log("Nothing to redo.");\n        }\n      },\n\n      /**\n       * Checks if there are actions that can be undone.\n       * @returns {boolean} True if undo is available, false otherwise.\n       */\n      get undoAvailable() {\n        return past.length > 0;\n      },\n\n      /**\n       * Checks if there are actions that can be redone.\n       * @returns {boolean} True if redo is available, false otherwise.\n       */\n      get redoAvailable() {\n        return future.length > 0;\n      },\n\n      /**\n       * Clears both the undo and redo stacks.\n       * @returns {boolean} True.\n       */\n      clear() {\n        console.log("Clearing undo/redo history.");\n        past.length = 0;\n        future.length = 0;\n        return true;\n      },\n    };\n  }\n\n  // If using modules (though not strictly required for this simple example)\n  // export { createUndoStack };\n<\/script> <script>\n  // 4. JavaScript Application Logic (script.js):\n\n  document.addEventListener("DOMContentLoaded", () => {\n    const canvas = document.getElementById("drawingCanvas");\n    const ctx = canvas.getContext("2d");\n    const undoBtn = document.getElementById("undoBtn");\n    const redoBtn = document.getElementById("redoBtn");\n    const clearBtn = document.getElementById("clearBtn");\n\n    // --- State ---\n    let isDrawing = false;\n    let currentStroke = []; // Array of points {x, y} for the stroke currently being drawn\n    let strokes = []; // Array of completed strokes (each stroke is an array of points)\n    const undoStack = createUndoStack();\n\n    // --- Canvas Setup ---\n    ctx.lineWidth = 3;\n    ctx.lineCap = "round";\n    ctx.strokeStyle = "#000000";\n\n    // --- Drawing Functions ---\n    function getMousePos(evt) {\n      const rect = canvas.getBoundingClientRect();\n      // Adjust for touch events\n      const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;\n      const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;\n      return {\n        x: clientX - rect.left,\n        y: clientY - rect.top,\n      };\n    }\n\n    function startDrawing(e) {\n      isDrawing = true;\n      currentStroke = []; // Start a new stroke\n      const pos = getMousePos(e);\n      currentStroke.push(pos);\n      // Draw the starting point immediately (optional, good for dots)\n      // ctx.beginPath();\n      // ctx.moveTo(pos.x, pos.y);\n      // ctx.lineTo(pos.x, pos.y); // Draw a tiny line segment or dot\n      // ctx.stroke();\n    }\n\n    function draw(e) {\n      if (!isDrawing) return;\n      const pos = getMousePos(e);\n\n      // Draw line segment visually as mouse moves\n      ctx.beginPath();\n      // Use the last point in currentStroke as the start\n      const lastPoint = currentStroke[currentStroke.length - 1];\n      ctx.moveTo(lastPoint.x, lastPoint.y);\n      ctx.lineTo(pos.x, pos.y);\n      ctx.stroke();\n\n      // Add point to the current stroke data\n      currentStroke.push(pos);\n      e.preventDefault(); // Prevent scrolling on touch devices\n    }\n\n    function stopDrawing() {\n      if (!isDrawing) return;\n      isDrawing = false;\n\n      // Only save if the stroke has more than one point (or your desired threshold)\n      if (currentStroke.length > 1) {\n        console.log(\n          \\`Stroke finished with \\${currentStroke.length} points. Pushing to undo stack.\\`\n        );\n        // --- UNDO STACK INTEGRATION ---\n        // We need functions to add and remove *this specific stroke*\n        const strokeToAdd = currentStroke; // Keep reference before resetting\n\n        const addStrokeAction = (strokeData) => {\n          console.log("Executing: Add Stroke");\n          strokes.push(strokeData);\n          redrawCanvas(); // Redraw everything including the new stroke\n          updateButtonStates();\n        };\n\n        const removeStrokeAction = (strokeData) => {\n          console.log("Executing: Remove Stroke");\n          // In a more complex scenario, you might search for strokeData,\n          // but here we assume it\'s always the last one added by the corresponding \'do\'.\n          const removed = strokes.pop();\n          // Optional check: console.log("Removed stroke matches expected?", removed === strokeData); // Note: This won\'t work due to cloning\n          redrawCanvas(); // Redraw without the removed stroke\n          updateButtonStates();\n        };\n\n        // Push the actions and the stroke data (which will be cloned)\n        // The push method executes addStrokeAction immediately.\n        undoStack.push(addStrokeAction, removeStrokeAction, strokeToAdd);\n        // We don\'t call addStrokeAction here, push does it!\n      } else {\n        console.log("Stroke too short, not saving.");\n      }\n\n      // Reset current stroke for the next drawing action\n      currentStroke = [];\n      // No need to redraw here, push already triggered redraw via addStrokeAction\n      updateButtonStates(); // Update buttons after potential push\n    }\n\n    function redrawCanvas() {\n      console.log(\\`Redrawing canvas with \\${strokes.length} strokes.\\`);\n      // Clear the entire canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Redraw all committed strokes\n      strokes.forEach((stroke) => {\n        if (stroke.length < 2) return; // Need at least two points to draw a line\n\n        ctx.beginPath();\n        ctx.moveTo(stroke[0].x, stroke[0].y);\n        for (let i = 1; i < stroke.length; i++) {\n          ctx.lineTo(stroke[i].x, stroke[i].y);\n        }\n        ctx.stroke();\n      });\n    }\n\n    // --- UI Update Function ---\n    function updateButtonStates() {\n      undoBtn.disabled = !undoStack.undoAvailable;\n      redoBtn.disabled = !undoStack.redoAvailable;\n      console.log(\n        \\`UI Update: Can Undo: \\${undoStack.undoAvailable}, Can Redo: \\${undoStack.redoAvailable}\\`\n      );\n    }\n\n    // --- Clear Functionality ---\n    function clearAll() {\n      strokes = []; // Clear the drawing data\n      undoStack.clear(); // Clear the history\n      redrawCanvas(); // Clear the visual canvas\n      updateButtonStates(); // Update buttons\n    }\n\n    // --- Event Listeners ---\n    // Mouse events\n    canvas.addEventListener("mousedown", startDrawing);\n    canvas.addEventListener("mousemove", draw);\n    canvas.addEventListener("mouseup", stopDrawing);\n    canvas.addEventListener("mouseout", stopDrawing); // Stop drawing if mouse leaves canvas\n\n    // Touch events\n    canvas.addEventListener("touchstart", startDrawing);\n    canvas.addEventListener("touchmove", draw);\n    canvas.addEventListener("touchend", stopDrawing);\n    canvas.addEventListener("touchcancel", stopDrawing); // Handle interruption\n\n    undoBtn.addEventListener("click", () => {\n      undoStack.undo();\n      // Note: The undoFn (removeStrokeAction) calls redraw and update buttons\n    });\n\n    redoBtn.addEventListener("click", () => {\n      undoStack.redo();\n      // Note: The doFn (addStrokeAction) calls redraw and update buttons\n    });\n\n    clearBtn.addEventListener("click", clearAll);\n\n    // --- Initial State ---\n    updateButtonStates(); // Set initial button states\n  });\n<\/script>'])), renderComponent($$result, "BaseLayout", $$BaseLayout, { "title": "Tiny Undo Stack - Drawing Example" }, { "default": ($$result2) => renderTemplate(_a || (_a = __template([" ", '<main> <h1>Simple Drawing with Undo/Redo</h1> <div class="controls"> <button id="undoBtn" disabled>Undo</button> <button id="redoBtn" disabled>Redo</button> <button id="clearBtn">Clear All</button> </div> <canvas id="drawingCanvas" width="600" height="400"></canvas> <p>Draw on the canvas by clicking and dragging.</p> <!--     \n        <script src="undoStack.js"><\/script>\n        <script src="script.js"><\/script> --> </main> '])), maybeRenderHead()) }));
}, "/home/matsu/Desktop/jy/src/pages/sketches/webdev/250402-undo_technique.astro", void 0);

const $$file = "/home/matsu/Desktop/jy/src/pages/sketches/webdev/250402-undo_technique.astro";
const $$url = "/sketches/webdev/250402-undo_technique";

const __vite_glob_0_29 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$250402UndoTechnique,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

export { __vite_glob_0_29 as _ };
