import { a as createComponent, b as renderTemplate, r as renderComponent, m as maybeRenderHead } from './astro/server_BuftSjIy.mjs';
import 'kleur/colors';
import { a as $$BaseLayout } from './BaseLayout_DEWwRiOq.mjs';
/* empty css                                                */

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(cooked.slice()) }));
var _a, _b;
const $$250326PerlinNoiseDeepseek = createComponent(($$result, $$props, $$slots) => {
  const sketch_title = "Organic Symphony";
  return renderTemplate(_b || (_b = __template(["", ' <script>\n  let canvas;\n  let gridSize = 30;\n  let noiseScale = 0.02;\n  let flowSpeed = 0.5;\n  let seed;\n  let particles = [];\n  let particleCount = 200;\n  let showGrid = true;\n  let colorTheme = "default";\n  let bgColor;\n  let lastFrameTime = 0;\n  const fpsLimit = 30;\n  const fpsInterval = 1000 / fpsLimit;\n\n  function setup() {\n    canvas = createCanvas(windowWidth, windowHeight);\n    canvas.parent("myCanvas");\n\n    // createCanvas(windowWidth, windowHeight);\n    colorMode(HSB, 360, 100, 100, 1);\n    pixelDensity(1);\n    bgColor = color(0, 0, 10);\n\n    initializeArt();\n    setupControls();\n  }\n\n  function initializeArt() {\n    seed = floor(random(100000));\n    noiseSeed(seed);\n    randomSeed(seed);\n\n    // Create particles\n    particles = [];\n    for (let i = 0; i < particleCount; i++) {\n      particles.push(createParticle());\n    }\n\n    // Initial background\n    drawNoiseBackground();\n  }\n\n  function createParticle() {\n    return {\n      pos: createVector(random(width), random(height)),\n      prevPos: createVector(random(width), random(height)),\n      hue: getThemeHue(),\n      life: random(100, 200),\n      maxLife: random(100, 200),\n      size: random(1, 3),\n      speed: random(1, 3),\n    };\n  }\n\n  function getThemeHue() {\n    switch (colorTheme) {\n      case "chaos":\n        return random(360);\n      case "serene":\n        return random(180, 240);\n      case "vibrant":\n        return random(0, 60);\n      case "minimal":\n        return 200;\n      default:\n        return random(360);\n    }\n  }\n\n  function draw() {\n    const now = performance.now();\n    const elapsed = now - lastFrameTime;\n\n    if (elapsed > fpsInterval) {\n      lastFrameTime = now - (elapsed % fpsInterval);\n\n      // Fade background for motion trails\n      background(bgColor.levels[0], bgColor.levels[1], bgColor.levels[2], 10);\n\n      // Draw grid layer if enabled\n      if (showGrid) {\n        drawOrganicGrid();\n      }\n\n      // Update and draw flow field\n      updateFlowField();\n    }\n  }\n\n  function windowResized() {\n    resizeCanvas(windowWidth, windowHeight);\n    drawNoiseBackground();\n  }\n\n  function drawNoiseBackground() {\n    push();\n    noStroke();\n    for (let x = 0; x < width; x += 2) {\n      for (let y = 0; y < height; y += 2) {\n        let n = noise(x * 0.01, y * 0.01);\n        fill(0, 0, map(n, 0, 1, 5, 15), 0.8);\n        rect(x, y, 2, 2);\n      }\n    }\n    pop();\n  }\n\n  function drawOrganicGrid() {\n    push();\n    noStroke();\n\n    for (let x = 0; x < width; x += gridSize) {\n      for (let y = 0; y < height; y += gridSize) {\n        // Multiple noise layers for varied effects\n        let hueNoise = noise(x * noiseScale, y * noiseScale);\n        let sizeNoise = noise(x * noiseScale * 1.3 + 100, y * noiseScale * 1.3);\n        let rotNoise = noise(x * noiseScale * 0.7 + 200, y * noiseScale * 0.7);\n        let shapeNoise = noise(x * noiseScale * 2 + 300, y * noiseScale * 2);\n        let brightnessNoise = noise(\n          x * noiseScale * 0.5 + 400,\n          y * noiseScale * 0.5\n        );\n\n        // Map noise to properties with theme variations\n        let hue, sat, bri, size, angle;\n\n        switch (colorTheme) {\n          case "chaos":\n            hue = map(hueNoise, 0, 1, 0, 360);\n            sat = map(sizeNoise, 0, 1, 70, 100);\n            bri = map(brightnessNoise, 0, 1, 50, 90);\n            size = map(pow(sizeNoise, 3), 0, 1, gridSize * 0.2, gridSize * 0.9);\n            break;\n          case "serene":\n            hue = map(hueNoise, 0, 1, 180, 240);\n            sat = 40;\n            bri = map(brightnessNoise, 0, 1, 40, 70);\n            size = map(sizeNoise, 0, 1, gridSize * 0.3, gridSize * 0.7);\n            break;\n          case "vibrant":\n            hue = map(hueNoise, 0, 1, 0, 120);\n            sat = 80;\n            bri = 70 + brightnessNoise * 20;\n            size = map(pow(sizeNoise, 2), 0, 1, gridSize * 0.4, gridSize);\n            break;\n          case "minimal":\n            hue = 200;\n            sat = 10;\n            bri = map(brightnessNoise, 0, 1, 30, 70);\n            size = map(sizeNoise, 0, 1, gridSize * 0.2, gridSize * 0.5);\n            break;\n          default:\n            hue = map(hueNoise, 0, 1, 150, 300);\n            sat = 60 + sizeNoise * 30;\n            bri = map(brightnessNoise, 0, 1, 40, 90);\n            size = map(sizeNoise, 0, 1, gridSize * 0.3, gridSize * 0.8);\n        }\n\n        angle = rotNoise * TWO_PI;\n        let alpha = map(size, gridSize * 0.2, gridSize * 0.9, 0.5, 0.9);\n\n        push();\n        translate(x + gridSize / 2, y + gridSize / 2);\n        rotate(angle);\n        fill(hue, sat, bri, alpha);\n\n        // Multiple shape types with different probabilities\n        if (shapeNoise < 0.3) {\n          ellipse(0, 0, size, size);\n        } else if (shapeNoise < 0.6) {\n          triangle(-size / 2, size / 2, size / 2, size / 2, 0, -size / 2);\n        } else if (shapeNoise < 0.9) {\n          rectMode(CENTER);\n          rect(0, 0, size * 0.8, size * 0.8, size * 0.2);\n        } else {\n          beginShape();\n          for (let i = 0; i < 5; i++) {\n            let a = (i * TWO_PI) / 5;\n            let r = size * 0.4;\n            vertex(r * cos(a), r * sin(a));\n          }\n          endShape(CLOSE);\n        }\n        pop();\n      }\n    }\n    pop();\n  }\n\n  function updateFlowField() {\n    for (let p of particles) {\n      // Store previous position\n      p.prevPos.set(p.pos.x, p.pos.y);\n\n      // Get noise-based angle from 3D noise (including time)\n      let angle =\n        noise(\n          p.pos.x * noiseScale * 0.5,\n          p.pos.y * noiseScale * 0.5,\n          frameCount * 0.005 * flowSpeed\n        ) *\n        TWO_PI *\n        4;\n\n      // Add some randomness to the angle for more organic motion\n      angle +=\n        (noise(p.pos.x * noiseScale * 2, frameCount * 0.003) * PI) / 4 - PI / 8;\n\n      // Move particle\n      let vel = p5.Vector.fromAngle(angle);\n      vel.mult(p.speed * flowSpeed);\n      p.pos.add(vel);\n      p.life--;\n\n      // Draw particle trail with theme-based colors\n      let trailAlpha = map(p.life, 0, p.maxLife, 0.1, 0.4);\n      let trailColor;\n\n      switch (colorTheme) {\n        case "serene":\n          trailColor = color(p.hue, 40, 90, trailAlpha);\n          break;\n        case "vibrant":\n          trailColor = color(p.hue, 80, 100, trailAlpha);\n          break;\n        case "minimal":\n          trailColor = color(200, 15, 100, trailAlpha * 0.5);\n          break;\n        default:\n          trailColor = color(p.hue, 70, 90, trailAlpha);\n      }\n\n      stroke(trailColor);\n      strokeWeight(p.size);\n      line(p.prevPos.x, p.prevPos.y, p.pos.x, p.pos.y);\n\n      // Particle renewal\n      if (\n        p.pos.x < -20 ||\n        p.pos.x > width + 20 ||\n        p.pos.y < -20 ||\n        p.pos.y > height + 20 ||\n        p.life <= 0\n      ) {\n        // Fade out particles near the edge\n        if (\n          !(p.pos.x < 0 || p.pos.x > width || p.pos.y < 0 || p.pos.y > height)\n        ) {\n          let fadeParticle = createParticle();\n          Object.assign(p, fadeParticle);\n        } else {\n          // Create new particle from edge\n          let newP = createParticle();\n          if (random() < 0.5) {\n            newP.pos.x = random([-10, width + 10]);\n            newP.pos.y = random(height);\n          } else {\n            newP.pos.y = random([-10, height + 10]);\n            newP.pos.x = random(width);\n          }\n          Object.assign(p, newP);\n        }\n      }\n    }\n  }\n\n  function setupControls() {\n    // Value displays\n    document.getElementById("noiseScale").addEventListener("input", (e) => {\n      noiseScale = parseFloat(e.target.value);\n      document.getElementById("noiseScaleValue").textContent =\n        noiseScale.toFixed(3);\n    });\n\n    document.getElementById("speed").addEventListener("input", (e) => {\n      flowSpeed = parseFloat(e.target.value);\n      document.getElementById("speedValue").textContent = flowSpeed.toFixed(1);\n    });\n\n    document.getElementById("particleCount").addEventListener("input", (e) => {\n      let newCount = parseInt(e.target.value);\n      if (newCount > particleCount) {\n        // Add particles\n        for (let i = particleCount; i < newCount; i++) {\n          particles.push(createParticle());\n        }\n      } else if (newCount < particleCount) {\n        // Remove particles\n        particles.length = newCount;\n      }\n      particleCount = newCount;\n      document.getElementById("particleCountValue").textContent = particleCount;\n    });\n\n    document.getElementById("gridSize").addEventListener("input", (e) => {\n      gridSize = parseInt(e.target.value);\n      document.getElementById("gridSizeValue").textContent = gridSize;\n    });\n\n    // Buttons\n    document.getElementById("newSeed").addEventListener("click", () => {\n      initializeArt();\n    });\n\n    document.getElementById("save").addEventListener("click", () => {\n      saveCanvas("organic-symphony-" + seed, "png");\n    });\n\n    document\n      .getElementById("toggleGrid")\n      .addEventListener("click", function () {\n        showGrid = !showGrid;\n        this.textContent = showGrid ? "Hide Grid" : "Show Grid";\n      });\n\n    // Presets\n    document.getElementById("presetSelect").addEventListener("change", (e) => {\n      colorTheme = e.target.value;\n\n      switch (colorTheme) {\n        case "chaos":\n          bgColor = color(0, 0, 5);\n          noiseScale = 0.015;\n          flowSpeed = 0.8;\n          break;\n        case "serene":\n          bgColor = color(200, 30, 15);\n          noiseScale = 0.025;\n          flowSpeed = 0.3;\n          break;\n        case "vibrant":\n          bgColor = color(0, 0, 10);\n          noiseScale = 0.02;\n          flowSpeed = 0.5;\n          break;\n        case "minimal":\n          bgColor = color(0, 0, 20);\n          noiseScale = 0.03;\n          flowSpeed = 0.2;\n          break;\n        default:\n          bgColor = color(0, 0, 10);\n          noiseScale = 0.02;\n          flowSpeed = 0.5;\n      }\n\n      // Update slider displays\n      document.getElementById("noiseScale").value = noiseScale;\n      document.getElementById("noiseScaleValue").textContent =\n        noiseScale.toFixed(3);\n      document.getElementById("speed").value = flowSpeed;\n      document.getElementById("speedValue").textContent = flowSpeed.toFixed(1);\n\n      // Reinitialize with new theme\n      initializeArt();\n    });\n  }\n<\/script>'])), renderComponent($$result, "BaseLayout", $$BaseLayout, { "title": sketch_title, "data-astro-cid-umxext6i": true }, { "default": ($$result2) => renderTemplate(_a || (_a = __template([' <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"><\/script>  ', '<div id="myCanvas" data-astro-cid-umxext6i></div> <div id="controls" data-astro-cid-umxext6i> <h3 data-astro-cid-umxext6i>Organic Symphony</h3> <div class="slider-container" data-astro-cid-umxext6i> <label for="noiseScale" data-astro-cid-umxext6i>Noise Scale: <span id="noiseScaleValue" data-astro-cid-umxext6i>0.02</span></label> <input type="range" id="noiseScale" min="0.001" max="0.05" step="0.001" value="0.02" data-astro-cid-umxext6i> </div> <div class="slider-container" data-astro-cid-umxext6i> <label for="speed" data-astro-cid-umxext6i>Flow Speed: <span id="speedValue" data-astro-cid-umxext6i>0.5</span></label> <input type="range" id="speed" min="0.1" max="2" step="0.1" value="0.5" data-astro-cid-umxext6i> </div> <div class="slider-container" data-astro-cid-umxext6i> <label for="particleCount" data-astro-cid-umxext6i>Particle Density: <span id="particleCountValue" data-astro-cid-umxext6i>200</span></label> <input type="range" id="particleCount" min="50" max="500" step="10" value="200" data-astro-cid-umxext6i> </div> <div class="slider-container" data-astro-cid-umxext6i> <label for="gridSize" data-astro-cid-umxext6i>Grid Size: <span id="gridSizeValue" data-astro-cid-umxext6i>30</span></label> <input type="range" id="gridSize" min="10" max="60" step="2" value="30" data-astro-cid-umxext6i> </div> <div data-astro-cid-umxext6i> <button id="newSeed" data-astro-cid-umxext6i>New Seed</button> <button id="save" data-astro-cid-umxext6i>Save Image</button> <button id="toggleGrid" data-astro-cid-umxext6i>Hide Grid</button> </div> <div id="presets" data-astro-cid-umxext6i> <label for="presetSelect" data-astro-cid-umxext6i>Presets:</label> <select id="presetSelect" data-astro-cid-umxext6i> <option value="default" data-astro-cid-umxext6i>Default</option> <option value="chaos" data-astro-cid-umxext6i>Controlled Chaos</option> <option value="serene" data-astro-cid-umxext6i>Serene Flow</option> <option value="vibrant" data-astro-cid-umxext6i>Vibrant Grid</option> <option value="minimal" data-astro-cid-umxext6i>Minimalist</option> </select> </div> </div> '])), maybeRenderHead()) }));
}, "/home/matsu/Desktop/jy/src/pages/sketches/2025/250326-perlin_noise_deepseek.astro", void 0);

const $$file = "/home/matsu/Desktop/jy/src/pages/sketches/2025/250326-perlin_noise_deepseek.astro";
const $$url = "/sketches/2025/250326-perlin_noise_deepseek";

const __vite_glob_0_17 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$250326PerlinNoiseDeepseek,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

export { __vite_glob_0_17 as _ };
