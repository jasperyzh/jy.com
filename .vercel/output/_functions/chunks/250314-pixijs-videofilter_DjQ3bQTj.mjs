import { a as createComponent, r as renderComponent, b as renderTemplate, m as maybeRenderHead } from './astro/server_BuftSjIy.mjs';
import 'kleur/colors';
import { a as $$BaseLayout } from './BaseLayout_DEWwRiOq.mjs';

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$250314PixijsVideofilter = createComponent(async ($$result, $$props, $$slots) => {
  const title = "PixiJS Video Filter";
  return renderTemplate`${renderComponent($$result, "BaseLayout", $$BaseLayout, { "title": title }, { "default": async ($$result2) => renderTemplate(_a || (_a = __template([" ", '<div class="relative min-h-screen bg-black"> <!-- PixiJS Canvas Container --> <div id="pixi-container" class="absolute top-0 left-0 w-full h-full"></div> <!-- UI Controls --> <div class="absolute bottom-5 left-0 right-0 mx-auto w-full max-w-xl px-4 py-2 rounded-lg bg-black/50 backdrop-blur-md z-10"> <div class="flex flex-wrap justify-center gap-4"> <button id="filter-blur" class="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded">Blur</button> <button id="filter-pixelate" class="px-3 py-1 bg-purple-500 hover:bg-purple-600 text-white rounded">Pixelate</button> <button id="filter-glitch" class="px-3 py-1 bg-red-500 hover:bg-red-600 text-white rounded">Glitch</button> <button id="filter-rgb" class="px-3 py-1 bg-green-500 hover:bg-green-600 text-white rounded">RGB Split</button> <button id="filter-reset" class="px-3 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded">Reset</button> </div> </div> </div>  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.9.0/dist/pixi.min.js"><\/script>  <script>\n    // Initialize filters namespace if not available\n    window.PIXI = window.PIXI || {};\n    window.PIXI.filters = window.PIXI.filters || {};\n    \n    // Create simple filter classes that can be used in our demo\n    if (!PIXI.filters.BlurFilter) {\n      PIXI.filters.BlurFilter = class BlurFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Simple vertex shader\n            `\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            `,\n            // Blur fragment shader\n            `\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform float blur;\n              uniform vec4 filterArea;\n              \n              void main(void) {\n                vec4 color = vec4(0.0);\n                vec2 pixelSize = vec2(1.0) / filterArea.xy;\n                \n                if (blur <= 0.0) {\n                  color = texture2D(uSampler, vTextureCoord);\n                } else {\n                  float blurSize = blur * 0.1;\n                  for(float x = -4.0; x <= 4.0; x++) {\n                    for(float y = -4.0; y <= 4.0; y++) {\n                      vec2 offset = vec2(x, y) * pixelSize * blurSize;\n                      color += texture2D(uSampler, vTextureCoord + offset);\n                    }\n                  }\n                  color /= 81.0;\n                }\n                \n                gl_FragColor = color;\n              }\n            `\n          );\n          this.blur = 0;\n          this.uniforms.blur = 0;\n        }\n        \n        get blur() {\n          return this.uniforms.blur;\n        }\n        \n        set blur(value) {\n          this.uniforms.blur = value;\n        }\n      };\n    }\n    \n    if (!PIXI.filters.PixelateFilter) {\n      PIXI.filters.PixelateFilter = class PixelateFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Vertex shader\n            `\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            `,\n            // Pixelate fragment shader\n            `\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform float size;\n              uniform vec4 filterArea;\n              \n              void main(void) {\n                vec2 pixelSize = vec2(size) / filterArea.xy;\n                if (pixelSize.x < 1.0 && pixelSize.y < 1.0) {\n                  gl_FragColor = texture2D(uSampler, vTextureCoord);\n                  return;\n                }\n                \n                vec2 coord = vTextureCoord - mod(vTextureCoord, pixelSize);\n                gl_FragColor = texture2D(uSampler, coord);\n              }\n            `\n          );\n          this.size = 1;\n          this.uniforms.size = 1;\n        }\n        \n        get size() {\n          return this.uniforms.size;\n        }\n        \n        set size(value) {\n          this.uniforms.size = value;\n        }\n      };\n    }\n    \n    if (!PIXI.filters.RGBSplitFilter) {\n      PIXI.filters.RGBSplitFilter = class RGBSplitFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Vertex shader\n            `\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            `,\n            // RGB Split fragment shader\n            `\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform vec2 red;\n              uniform vec2 green;\n              uniform vec2 blue;\n              \n              void main(void) {\n                vec4 colorR = texture2D(uSampler, vTextureCoord + red / 100.0);\n                vec4 colorG = texture2D(uSampler, vTextureCoord + green / 100.0);\n                vec4 colorB = texture2D(uSampler, vTextureCoord + blue / 100.0);\n                \n                gl_FragColor = vec4(colorR.r, colorG.g, colorB.b, (colorR.a + colorG.a + colorB.a) / 3.0);\n              }\n            `\n          );\n          \n          this.red = { x: 0, y: 0 };\n          this.green = { x: 0, y: 0 };\n          this.blue = { x: 0, y: 0 };\n          \n          this.uniforms.red = [0, 0];\n          this.uniforms.green = [0, 0];\n          this.uniforms.blue = [0, 0];\n        }\n        \n        get red() {\n          return { x: this.uniforms.red[0], y: this.uniforms.red[1] };\n        }\n        \n        set red(value) {\n          this.uniforms.red = [value.x, value.y];\n        }\n        \n        get green() {\n          return { x: this.uniforms.green[0], y: this.uniforms.green[1] };\n        }\n        \n        set green(value) {\n          this.uniforms.green = [value.x, value.y];\n        }\n        \n        get blue() {\n          return { x: this.uniforms.blue[0], y: this.uniforms.blue[1] };\n        }\n        \n        set blue(value) {\n          this.uniforms.blue = [value.x, value.y];\n        }\n      };\n    }\n    \n    if (!PIXI.filters.GlitchFilter) {\n      PIXI.filters.GlitchFilter = class GlitchFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Vertex shader\n            `\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            `,\n            // Glitch fragment shader\n            `\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform float slices;\n              uniform float offset;\n              uniform float seed;\n              \n              void main(void) {\n                vec2 coord = vTextureCoord;\n                \n                if (slices > 0.0) {\n                  float sliceWidth = 1.0 / slices;\n                  float sliceIndex = floor(coord.x / sliceWidth);\n                  float distortion = seed + sliceIndex;\n                  coord.x += sin(distortion) * offset * sliceWidth;\n                }\n                \n                gl_FragColor = texture2D(uSampler, coord);\n              }\n            `\n          );\n          \n          this.slices = 0;\n          this.offset = 0;\n          this.seed = 0;\n          \n          this.uniforms.slices = 0;\n          this.uniforms.offset = 0;\n          this.uniforms.seed = 0;\n        }\n        \n        get slices() {\n          return this.uniforms.slices;\n        }\n        \n        set slices(value) {\n          this.uniforms.slices = value;\n        }\n        \n        get offset() {\n          return this.uniforms.offset;\n        }\n        \n        set offset(value) {\n          this.uniforms.offset = value;\n        }\n        \n        get seed() {\n          return this.uniforms.seed;\n        }\n        \n        set seed(value) {\n          this.uniforms.seed = value;\n        }\n      };\n    }\n  <\/script> <script type="module">\n    // PixiJS v8 initialization\n    const initPixi = async () => {\n      try {\n        // Create a new application\n        const app = new PIXI.Application();\n\n        // Initialize the application\n        await app.init({ \n          resizeTo: window,\n          background: \'transparent\', // Transparent background\n          antialias: true\n        });\n\n        // Append the application canvas to the container\n        document.getElementById("pixi-container").appendChild(app.canvas);\n\n        // Create play button that can be used to trigger the video\n        const button = new PIXI.Graphics()\n          .roundRect(0, 0, 100, 100, 10)\n          .fill({ color: 0xffffff, alpha: 0.5 })\n          .beginPath()\n          .moveTo(36, 30)\n          .lineTo(36, 70)\n          .lineTo(70, 50)\n          .closePath()\n          .fill({ color: 0xffffff });\n\n        // Position the button\n        button.position.x = (app.screen.width - button.width) / 2;\n        button.position.y = (app.screen.height - button.height) / 2;\n\n        // Enable interactivity on the button\n        button.eventMode = \'static\';\n        button.cursor = \'pointer\';\n\n        // Add to the stage\n        app.stage.addChild(button);\n\n\n        // Listen for a click/tap event to start playing the video\n        button.on(\'pointertap\', async () => {\n          try {\n            // Don\'t need the button anymore\n            button.destroy();\n\n            // Load the video texture using Assets API\n            const videoTexture = await PIXI.Assets.load(\'https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\');\n\n            // Create a new Sprite using the video texture\n            const videoSprite = new PIXI.Sprite(videoTexture);\n\n            // Center the sprite\n            videoSprite.anchor.set(0.5);\n            videoSprite.position.x = app.screen.width / 2;\n            videoSprite.position.y = app.screen.height / 2;\n\n            // Scale to fit the screen while maintaining aspect ratio\n            const scaleX = app.screen.width / videoTexture.source.videoWidth;\n            const scaleY = app.screen.height / videoTexture.source.videoHeight;\n            const scale = Math.max(scaleX, scaleY);\n            videoSprite.scale.set(scale);\n\n            app.stage.addChild(videoSprite);\n\n            // Create filters - access through PIXI.filters namespace for PixiJS v8\n            const blurFilter = new PIXI.filters.BlurFilter();\n            blurFilter.blur = 0;\n\n            const pixelateFilter = new PIXI.filters.PixelateFilter();\n            pixelateFilter.size = 1;\n\n            const glitchFilter = new PIXI.filters.GlitchFilter();\n            glitchFilter.slices = 0;\n            glitchFilter.offset = 0;\n\n            const rgbFilter = new PIXI.filters.RGBSplitFilter();\n            rgbFilter.red = { x: 0, y: 0 };\n            rgbFilter.green = { x: 0, y: 0 };\n            rgbFilter.blue = { x: 0, y: 0 };\n\n            // Button event listeners\n            document\n              .getElementById("filter-blur")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [blurFilter];\n                blurFilter.blur = 10;\n              });\n\n            document\n              .getElementById("filter-pixelate")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [pixelateFilter];\n                pixelateFilter.size = 10;\n              });\n\n            document\n              .getElementById("filter-glitch")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [glitchFilter];\n                glitchFilter.slices = 10;\n                glitchFilter.offset = 10;\n              });\n\n            document\n              .getElementById("filter-rgb")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [rgbFilter];\n                rgbFilter.red = { x: 10, y: 0 };\n                rgbFilter.blue = { x: -10, y: 0 };\n              });\n\n            document\n              .getElementById("filter-reset")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [];\n              });\n\n            // Reset all filters to initial state\n            function resetFilters() {\n              blurFilter.blur = 0;\n              pixelateFilter.size = 1;\n              glitchFilter.slices = 0;\n              glitchFilter.offset = 0;\n              rgbFilter.red = { x: 0, y: 0 };\n              rgbFilter.green = { x: 0, y: 0 };\n              rgbFilter.blue = { x: 0, y: 0 };\n            }\n\n            // Add filter animation with ticker\n            app.ticker.add(() => {\n              if (videoSprite.filters?.includes(glitchFilter)) {\n                glitchFilter.seed = Math.random();\n              }\n\n              if (videoSprite.filters?.includes(rgbFilter)) {\n                const time = Date.now() / 1000;\n                rgbFilter.red.x = Math.sin(time) * 10;\n                rgbFilter.blue.x = Math.cos(time) * 10;\n              }\n            });\n\n            // Handle window resize - PixiJS v8 handles most of this automatically\n            window.addEventListener("resize", () => {\n              // Just update sprite position and scale\n              videoSprite.position.x = app.screen.width / 2;\n              videoSprite.position.y = app.screen.height / 2;\n\n              const scaleX = app.screen.width / videoTexture.source.videoWidth;\n              const scaleY = app.screen.height / videoTexture.source.videoHeight;\n              const scale = Math.max(scaleX, scaleY);\n              videoSprite.scale.set(scale);\n            });\n          } catch (videoError) {\n            console.error("Error loading video:", videoError);\n            app.stage.removeChild(button);\n            \n            // Display error message\n            const errorStyle = new PIXI.TextStyle({\n              fill: "#ffffff",\n              fontSize: 18,\n              fontFamily: "Arial"\n            });\n            \n            const errorText = new PIXI.Text(`Error loading video: ${videoError.message}`, errorStyle);\n            errorText.anchor.set(0.5);\n            errorText.position.x = app.screen.width / 2;\n            errorText.position.y = app.screen.height / 2;\n            app.stage.addChild(errorText);\n          }\n        });\n      } catch (error) {\n        console.error("Error initializing PixiJS:", error);\n        document.getElementById("pixi-container").innerHTML = `\n          <div class="flex items-center justify-center h-full w-full bg-gray-900 text-white">\n            <div class="text-center">\n              <h2 class="text-xl mb-4">Error loading PixiJS</h2>\n              <p>${error.message}</p>\n            </div>\n          </div>\n        `;\n      }\n    };\n\n    document.addEventListener("DOMContentLoaded", initPixi);\n  <\/script> '], [" ", '<div class="relative min-h-screen bg-black"> <!-- PixiJS Canvas Container --> <div id="pixi-container" class="absolute top-0 left-0 w-full h-full"></div> <!-- UI Controls --> <div class="absolute bottom-5 left-0 right-0 mx-auto w-full max-w-xl px-4 py-2 rounded-lg bg-black/50 backdrop-blur-md z-10"> <div class="flex flex-wrap justify-center gap-4"> <button id="filter-blur" class="px-3 py-1 bg-blue-500 hover:bg-blue-600 text-white rounded">Blur</button> <button id="filter-pixelate" class="px-3 py-1 bg-purple-500 hover:bg-purple-600 text-white rounded">Pixelate</button> <button id="filter-glitch" class="px-3 py-1 bg-red-500 hover:bg-red-600 text-white rounded">Glitch</button> <button id="filter-rgb" class="px-3 py-1 bg-green-500 hover:bg-green-600 text-white rounded">RGB Split</button> <button id="filter-reset" class="px-3 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded">Reset</button> </div> </div> </div>  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.9.0/dist/pixi.min.js"><\/script>  <script>\n    // Initialize filters namespace if not available\n    window.PIXI = window.PIXI || {};\n    window.PIXI.filters = window.PIXI.filters || {};\n    \n    // Create simple filter classes that can be used in our demo\n    if (!PIXI.filters.BlurFilter) {\n      PIXI.filters.BlurFilter = class BlurFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Simple vertex shader\n            \\`\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            \\`,\n            // Blur fragment shader\n            \\`\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform float blur;\n              uniform vec4 filterArea;\n              \n              void main(void) {\n                vec4 color = vec4(0.0);\n                vec2 pixelSize = vec2(1.0) / filterArea.xy;\n                \n                if (blur <= 0.0) {\n                  color = texture2D(uSampler, vTextureCoord);\n                } else {\n                  float blurSize = blur * 0.1;\n                  for(float x = -4.0; x <= 4.0; x++) {\n                    for(float y = -4.0; y <= 4.0; y++) {\n                      vec2 offset = vec2(x, y) * pixelSize * blurSize;\n                      color += texture2D(uSampler, vTextureCoord + offset);\n                    }\n                  }\n                  color /= 81.0;\n                }\n                \n                gl_FragColor = color;\n              }\n            \\`\n          );\n          this.blur = 0;\n          this.uniforms.blur = 0;\n        }\n        \n        get blur() {\n          return this.uniforms.blur;\n        }\n        \n        set blur(value) {\n          this.uniforms.blur = value;\n        }\n      };\n    }\n    \n    if (!PIXI.filters.PixelateFilter) {\n      PIXI.filters.PixelateFilter = class PixelateFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Vertex shader\n            \\`\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            \\`,\n            // Pixelate fragment shader\n            \\`\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform float size;\n              uniform vec4 filterArea;\n              \n              void main(void) {\n                vec2 pixelSize = vec2(size) / filterArea.xy;\n                if (pixelSize.x < 1.0 && pixelSize.y < 1.0) {\n                  gl_FragColor = texture2D(uSampler, vTextureCoord);\n                  return;\n                }\n                \n                vec2 coord = vTextureCoord - mod(vTextureCoord, pixelSize);\n                gl_FragColor = texture2D(uSampler, coord);\n              }\n            \\`\n          );\n          this.size = 1;\n          this.uniforms.size = 1;\n        }\n        \n        get size() {\n          return this.uniforms.size;\n        }\n        \n        set size(value) {\n          this.uniforms.size = value;\n        }\n      };\n    }\n    \n    if (!PIXI.filters.RGBSplitFilter) {\n      PIXI.filters.RGBSplitFilter = class RGBSplitFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Vertex shader\n            \\`\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            \\`,\n            // RGB Split fragment shader\n            \\`\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform vec2 red;\n              uniform vec2 green;\n              uniform vec2 blue;\n              \n              void main(void) {\n                vec4 colorR = texture2D(uSampler, vTextureCoord + red / 100.0);\n                vec4 colorG = texture2D(uSampler, vTextureCoord + green / 100.0);\n                vec4 colorB = texture2D(uSampler, vTextureCoord + blue / 100.0);\n                \n                gl_FragColor = vec4(colorR.r, colorG.g, colorB.b, (colorR.a + colorG.a + colorB.a) / 3.0);\n              }\n            \\`\n          );\n          \n          this.red = { x: 0, y: 0 };\n          this.green = { x: 0, y: 0 };\n          this.blue = { x: 0, y: 0 };\n          \n          this.uniforms.red = [0, 0];\n          this.uniforms.green = [0, 0];\n          this.uniforms.blue = [0, 0];\n        }\n        \n        get red() {\n          return { x: this.uniforms.red[0], y: this.uniforms.red[1] };\n        }\n        \n        set red(value) {\n          this.uniforms.red = [value.x, value.y];\n        }\n        \n        get green() {\n          return { x: this.uniforms.green[0], y: this.uniforms.green[1] };\n        }\n        \n        set green(value) {\n          this.uniforms.green = [value.x, value.y];\n        }\n        \n        get blue() {\n          return { x: this.uniforms.blue[0], y: this.uniforms.blue[1] };\n        }\n        \n        set blue(value) {\n          this.uniforms.blue = [value.x, value.y];\n        }\n      };\n    }\n    \n    if (!PIXI.filters.GlitchFilter) {\n      PIXI.filters.GlitchFilter = class GlitchFilter extends PIXI.Filter {\n        constructor() {\n          super(\n            // Vertex shader\n            \\`\n              attribute vec2 aVertexPosition;\n              attribute vec2 aTextureCoord;\n              uniform mat3 projectionMatrix;\n              varying vec2 vTextureCoord;\n              void main(void) {\n                gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n                vTextureCoord = aTextureCoord;\n              }\n            \\`,\n            // Glitch fragment shader\n            \\`\n              varying vec2 vTextureCoord;\n              uniform sampler2D uSampler;\n              uniform float slices;\n              uniform float offset;\n              uniform float seed;\n              \n              void main(void) {\n                vec2 coord = vTextureCoord;\n                \n                if (slices > 0.0) {\n                  float sliceWidth = 1.0 / slices;\n                  float sliceIndex = floor(coord.x / sliceWidth);\n                  float distortion = seed + sliceIndex;\n                  coord.x += sin(distortion) * offset * sliceWidth;\n                }\n                \n                gl_FragColor = texture2D(uSampler, coord);\n              }\n            \\`\n          );\n          \n          this.slices = 0;\n          this.offset = 0;\n          this.seed = 0;\n          \n          this.uniforms.slices = 0;\n          this.uniforms.offset = 0;\n          this.uniforms.seed = 0;\n        }\n        \n        get slices() {\n          return this.uniforms.slices;\n        }\n        \n        set slices(value) {\n          this.uniforms.slices = value;\n        }\n        \n        get offset() {\n          return this.uniforms.offset;\n        }\n        \n        set offset(value) {\n          this.uniforms.offset = value;\n        }\n        \n        get seed() {\n          return this.uniforms.seed;\n        }\n        \n        set seed(value) {\n          this.uniforms.seed = value;\n        }\n      };\n    }\n  <\/script> <script type="module">\n    // PixiJS v8 initialization\n    const initPixi = async () => {\n      try {\n        // Create a new application\n        const app = new PIXI.Application();\n\n        // Initialize the application\n        await app.init({ \n          resizeTo: window,\n          background: \'transparent\', // Transparent background\n          antialias: true\n        });\n\n        // Append the application canvas to the container\n        document.getElementById("pixi-container").appendChild(app.canvas);\n\n        // Create play button that can be used to trigger the video\n        const button = new PIXI.Graphics()\n          .roundRect(0, 0, 100, 100, 10)\n          .fill({ color: 0xffffff, alpha: 0.5 })\n          .beginPath()\n          .moveTo(36, 30)\n          .lineTo(36, 70)\n          .lineTo(70, 50)\n          .closePath()\n          .fill({ color: 0xffffff });\n\n        // Position the button\n        button.position.x = (app.screen.width - button.width) / 2;\n        button.position.y = (app.screen.height - button.height) / 2;\n\n        // Enable interactivity on the button\n        button.eventMode = \'static\';\n        button.cursor = \'pointer\';\n\n        // Add to the stage\n        app.stage.addChild(button);\n\n\n        // Listen for a click/tap event to start playing the video\n        button.on(\'pointertap\', async () => {\n          try {\n            // Don\'t need the button anymore\n            button.destroy();\n\n            // Load the video texture using Assets API\n            const videoTexture = await PIXI.Assets.load(\'https://storage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\');\n\n            // Create a new Sprite using the video texture\n            const videoSprite = new PIXI.Sprite(videoTexture);\n\n            // Center the sprite\n            videoSprite.anchor.set(0.5);\n            videoSprite.position.x = app.screen.width / 2;\n            videoSprite.position.y = app.screen.height / 2;\n\n            // Scale to fit the screen while maintaining aspect ratio\n            const scaleX = app.screen.width / videoTexture.source.videoWidth;\n            const scaleY = app.screen.height / videoTexture.source.videoHeight;\n            const scale = Math.max(scaleX, scaleY);\n            videoSprite.scale.set(scale);\n\n            app.stage.addChild(videoSprite);\n\n            // Create filters - access through PIXI.filters namespace for PixiJS v8\n            const blurFilter = new PIXI.filters.BlurFilter();\n            blurFilter.blur = 0;\n\n            const pixelateFilter = new PIXI.filters.PixelateFilter();\n            pixelateFilter.size = 1;\n\n            const glitchFilter = new PIXI.filters.GlitchFilter();\n            glitchFilter.slices = 0;\n            glitchFilter.offset = 0;\n\n            const rgbFilter = new PIXI.filters.RGBSplitFilter();\n            rgbFilter.red = { x: 0, y: 0 };\n            rgbFilter.green = { x: 0, y: 0 };\n            rgbFilter.blue = { x: 0, y: 0 };\n\n            // Button event listeners\n            document\n              .getElementById("filter-blur")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [blurFilter];\n                blurFilter.blur = 10;\n              });\n\n            document\n              .getElementById("filter-pixelate")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [pixelateFilter];\n                pixelateFilter.size = 10;\n              });\n\n            document\n              .getElementById("filter-glitch")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [glitchFilter];\n                glitchFilter.slices = 10;\n                glitchFilter.offset = 10;\n              });\n\n            document\n              .getElementById("filter-rgb")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [rgbFilter];\n                rgbFilter.red = { x: 10, y: 0 };\n                rgbFilter.blue = { x: -10, y: 0 };\n              });\n\n            document\n              .getElementById("filter-reset")\n              .addEventListener("click", () => {\n                resetFilters();\n                videoSprite.filters = [];\n              });\n\n            // Reset all filters to initial state\n            function resetFilters() {\n              blurFilter.blur = 0;\n              pixelateFilter.size = 1;\n              glitchFilter.slices = 0;\n              glitchFilter.offset = 0;\n              rgbFilter.red = { x: 0, y: 0 };\n              rgbFilter.green = { x: 0, y: 0 };\n              rgbFilter.blue = { x: 0, y: 0 };\n            }\n\n            // Add filter animation with ticker\n            app.ticker.add(() => {\n              if (videoSprite.filters?.includes(glitchFilter)) {\n                glitchFilter.seed = Math.random();\n              }\n\n              if (videoSprite.filters?.includes(rgbFilter)) {\n                const time = Date.now() / 1000;\n                rgbFilter.red.x = Math.sin(time) * 10;\n                rgbFilter.blue.x = Math.cos(time) * 10;\n              }\n            });\n\n            // Handle window resize - PixiJS v8 handles most of this automatically\n            window.addEventListener("resize", () => {\n              // Just update sprite position and scale\n              videoSprite.position.x = app.screen.width / 2;\n              videoSprite.position.y = app.screen.height / 2;\n\n              const scaleX = app.screen.width / videoTexture.source.videoWidth;\n              const scaleY = app.screen.height / videoTexture.source.videoHeight;\n              const scale = Math.max(scaleX, scaleY);\n              videoSprite.scale.set(scale);\n            });\n          } catch (videoError) {\n            console.error("Error loading video:", videoError);\n            app.stage.removeChild(button);\n            \n            // Display error message\n            const errorStyle = new PIXI.TextStyle({\n              fill: "#ffffff",\n              fontSize: 18,\n              fontFamily: "Arial"\n            });\n            \n            const errorText = new PIXI.Text(\\`Error loading video: \\${videoError.message}\\`, errorStyle);\n            errorText.anchor.set(0.5);\n            errorText.position.x = app.screen.width / 2;\n            errorText.position.y = app.screen.height / 2;\n            app.stage.addChild(errorText);\n          }\n        });\n      } catch (error) {\n        console.error("Error initializing PixiJS:", error);\n        document.getElementById("pixi-container").innerHTML = \\`\n          <div class="flex items-center justify-center h-full w-full bg-gray-900 text-white">\n            <div class="text-center">\n              <h2 class="text-xl mb-4">Error loading PixiJS</h2>\n              <p>\\${error.message}</p>\n            </div>\n          </div>\n        \\`;\n      }\n    };\n\n    document.addEventListener("DOMContentLoaded", initPixi);\n  <\/script> '])), maybeRenderHead()) })}`;
}, "/home/matsu/Desktop/jy/src/pages/sketches/2025/250314-pixijs-videofilter.astro", void 0);

const $$file = "/home/matsu/Desktop/jy/src/pages/sketches/2025/250314-pixijs-videofilter.astro";
const $$url = "/sketches/2025/250314-pixijs-videofilter";

const __vite_glob_0_1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  default: $$250314PixijsVideofilter,
  file: $$file,
  url: $$url
}, Symbol.toStringTag, { value: 'Module' }));

export { __vite_glob_0_1 as _ };
