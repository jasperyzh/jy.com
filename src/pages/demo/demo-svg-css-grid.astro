---
layout: "../layouts/Layout.astro"
---

<!-- Load SVG.js library for easier SVG manipulation -->
<script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.2.4/svg.min.js"></script>

<div class="container">
  <h1>SVG Grid Composition</h1>
  <div id="svg-grid-container" class="svg-grid"></div>
  <div class="controls">
    <button id="export-svg-btn">Export Combined SVG</button>
  </div>
</div>

<style>
  .container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }

  h1 {
    text-align: center;
    margin-bottom: 20px;
  }

  .svg-grid {
    display: grid;
    grid-template-columns: repeat(4, 100px);
    grid-gap: 10px;
    margin-bottom: 20px;

    
  }

  .svg-cell {
    background-color: white;
    border: 1px solid #ddd;
    min-height: 120px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .controls {
    text-align: center;
    margin-top: 20px;
  }

  button {
    padding: 10px 20px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
  }

  button:hover {
    background-color: #0056b3;
  }
</style>


<script is:inline>
document.addEventListener('DOMContentLoaded', function() {
  // Configuration
  const gridContainer = document.getElementById('svg-grid-container');
  const cellSize = 120;
  // Get the actual column count from CSS
  const gridStyle = window.getComputedStyle(gridContainer);
  const gridTemplateColumns = gridStyle.getPropertyValue('grid-template-columns');
  // Count the number of columns by counting the number of values in the grid-template-columns
  const cols = gridTemplateColumns.split(' ').length;
  console.log(`Detected ${cols} columns in the grid`);
  
  // Calculate rows based on total cells and columns
  const gap = 10;
  
  if (!gridContainer) {
      console.error("SVG grid container not found!");
      return;
  }
  
  if (typeof SVG === 'undefined') {
      console.error("SVG.js library not loaded!");
      return;
  }
  
  // Create grid cells
  const cellCount = cols * 3; // 3 rows by default, can be adjusted
  for (let i = 0; i < cellCount; i++) {
    const cell = document.createElement('div');
    cell.className = 'svg-cell';
    cell.id = `cell-${i}`;
    gridContainer.appendChild(cell);
  }
  
  // Initialize SVG in each cell
  const svgCells = [];
  
  document.querySelectorAll('.svg-cell').forEach((cell, index) => {
    try {
      // Create SVG with SVG.js
      const draw = SVG().addTo(`#${cell.id}`).size(cellSize, cellSize);
      
      // Draw different patterns based on position
      switch (index % 5) {
        case 0: // Concentric circles
          draw.circle(80).fill('#ffe3e3').stroke({ color: '#ff6b6b', width: 2 }).center(cellSize/2, cellSize/2);
          draw.circle(40).fill('#ffa8a8').center(cellSize/2, cellSize/2);
          break;
        
        case 1: // Rectangles
          draw.rect(80, 80).radius(5).fill('#e7f5ff').stroke({ color: '#339af0', width: 2 }).move(20, 20);
          draw.rect(40, 40).fill('#a5d8ff').move(40, 40);
          break;
        
        case 2: // Lines
          for (let i = 0; i < 8; i++) {
            let y = 20 + i * 10;
            draw.line(20, y, 100, y).stroke({ color: '#51cf66', width: 2 });
          }
          break;
        
        case 3: // Star
          const points = [];
          const cx = cellSize/2;
          const cy = cellSize/2;
          const outerRadius = 40;
          const innerRadius = 20;
          
          for (let i = 0; i < 10; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = Math.PI * 2 * i / 10 - Math.PI / 2;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            points.push([x, y]);
          }
          
          const pointsString = points.map(p => p.join(',')).join(' ');
          draw.polygon(pointsString).fill('#fff9db').stroke({ color: '#fcc419', width: 2 });
          break;
        
        case 4: // Grid
          for (let i = 0; i < 4; i++) {
            const pos = 30 + i * 20;
            draw.line(30, pos, 90, pos).stroke({ color: '#9775fa', width: 2 });
            draw.line(pos, 30, pos, 90).stroke({ color: '#9775fa', width: 2 });
          }
          break;
      }
      
      // Store the SVG element for export along with its actual position in the grid
      const cellRect = cell.getBoundingClientRect();
      svgCells.push({
        element: draw,
        position: {
          row: Math.floor(index / cols),
          col: index % cols,
          // Store the actual positions from the layout
          x: cellRect.left - gridContainer.getBoundingClientRect().left,
          y: cellRect.top - gridContainer.getBoundingClientRect().top,
          width: cellRect.width,
          height: cellRect.height
        }
      });
    } catch (error) {
      console.error(`Error creating SVG in cell ${index}:`, error);
      cell.innerHTML = `<div style="color:red; padding:10px;">SVG Error: ${error.message}</div>`;
    }
  });
  
  // Export functionality
  document.getElementById('export-svg-btn').addEventListener('click', function() {
    if (svgCells.length === 0) {
      console.error("No SVG cells were created. Cannot export.");
      return;
    }
    
    try {
      // Get the actual dimensions of the grid container
      const gridRect = gridContainer.getBoundingClientRect();
      const containerWidth = gridRect.width;
      const containerHeight = gridRect.height;
      
      // Create a container div to hold the temporary SVG
      const container = document.createElement('div');
      container.style.position = 'absolute';
      container.style.left = '-9999px';
      document.body.appendChild(container);
      
      // Create the combined SVG with the correct dimensions
      const combinedSvg = SVG().addTo(container).size(containerWidth, containerHeight);
      
      // Create background
      combinedSvg.rect(containerWidth, containerHeight).fill('#f8f9fa');
      
      // Add each cell SVG using its actual position in the grid
      svgCells.forEach(cell => {
        try {
          // Clone the SVG content
          const cellSvg = cell.element.clone();
          
          // Position it using the actual position from the grid
          const group = combinedSvg.group();
          group.svg(cellSvg.svg());
          
          // Use the actual position from the grid
          const { x, y } = cell.position;
          group.move(x, y);
        } catch (e) {
          console.error("Error adding cell to export:", e);
        }
      });
      
      // Export the SVG
      const svgData = combinedSvg.svg();
      
      // Create a Blob and download
      const blob = new Blob([svgData], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = 'svg-grid-composition.svg';
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      document.body.removeChild(a);
      document.body.removeChild(container);
      URL.revokeObjectURL(url);
      
      console.log('SVG exported successfully!');
    } catch (error) {
      console.error("Error exporting SVG:", error);
    }
  });
});
</script>