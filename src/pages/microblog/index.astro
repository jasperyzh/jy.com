---
/**
 * Microblog main page
 * Displays a feed of microblog posts with pagination
 */
import Layout from "@/layouts/BaseLayout.astro";
import MicroblogFeed from "@/components/microblog/MicroblogFeed.astro";
import { getCollection } from "astro:content";
import { formatYymmddDate } from "@/utils/formatDate";

// Pagination configuration
export const POSTS_PER_PAGE = 10;

// Get all microblog posts
const allMicroblogPosts = await getCollection("microblog");

// Sort posts by date (newest first)
const sortedPosts = allMicroblogPosts.sort((a, b) => {
  const dateA = a.data.pubDate instanceof Date ? a.data.pubDate : new Date();
  const dateB = b.data.pubDate instanceof Date ? b.data.pubDate : new Date();
  return dateB.getTime() - dateA.getTime();
});

// Filter out draft posts and private posts in production
const publishedPosts = import.meta.env.PROD
  ? sortedPosts.filter((post) => !post.data.draft && !post.data.isPrivate)
  : sortedPosts;

// Calculate pagination
const totalPages = Math.ceil(publishedPosts.length / POSTS_PER_PAGE);
const currentPage = 1;
const start = 0;
const end = start + POSTS_PER_PAGE;
const paginatedPosts = publishedPosts.slice(start, end);

// Calculate previous and next page URLs
const prevUrl = currentPage > 1 ? `/microblog/page/${currentPage - 1}` : null;
const nextUrl =
  currentPage < totalPages ? `/microblog/page/${currentPage + 1}` : null;
---

<Layout title="Microblog" description="Short-form updates and thoughts">
  <main>
    <div class="twitter-header">
      <div class="header-content">
        <h1>Microblog</h1>
        <p class="bio">
          Quick thoughts, photos, and updates that don't warrant a full blog post
        </p>
      </div>
    </div>
    
    <div class="twitter-container">
      <MicroblogFeed 
        posts={paginatedPosts}
        {currentPage}
        {totalPages}
        {prevUrl}
        {nextUrl}
      />
    </div>
  </main>
</Layout>

<style>
  main {
    max-width: 100%;
  }
  
  .twitter-header {
    background-color: #1DA1F2;
    color: white;
    padding: 2rem 0;
  }
  
  .header-content {
    max-width: 600px;
    margin: 0 auto;
    padding: 0 1rem;
  }
  
  h1 {
    font-size: 2rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
  }
  
  .bio {
    font-size: 1.1rem;
    opacity: 0.9;
  }
  
  .twitter-container {
    padding: 1rem 0;
    background-color: #f7f9fa;
    min-height: calc(100vh - 180px);
  }
  
  @media (max-width: 768px) {
    h1 {
      font-size: 1.75rem;
    }
    
    .bio {
      font-size: 1rem;
    }
  }
</style>

<script>
  // Import Bootstrap icons if not already loaded
  if (!document.querySelector('link[href*="bootstrap-icons"]')) {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = 'https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.0/font/bootstrap-icons.css';
    document.head.appendChild(link);
  }
  
  // Add PrismJS styling for code blocks - using is:inline to avoid TypeScript errors
</script>

<script is:inline>
  // Load PrismJS for syntax highlighting
  document.addEventListener('DOMContentLoaded', function() {
    // Add PrismJS CSS
    if (!document.querySelector('link[href*="prismjs"]')) {
      var prismCSS = document.createElement('link');
      prismCSS.rel = 'stylesheet';
      prismCSS.href = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css';
      document.head.appendChild(prismCSS);
      
      // Add PrismJS script
      var prismScript = document.createElement('script');
      prismScript.src = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js';
      document.head.appendChild(prismScript);
      
      // Add markdown support
      var markdownScript = document.createElement('script');
      markdownScript.src = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-markdown.min.js';
      document.head.appendChild(markdownScript);
      
      prismScript.onload = function() {
        if (typeof Prism !== 'undefined') {
          Prism.highlightAll();
        }
      };
    }
  });
</script>