---
import Layout from "@/layouts/Layout.astro";
---

<Layout title="Daily Sketch Generator">
  <main class="container grid lg:grid-cols-2 gap-4 px-2">
    <header class="lg:col-span-2">
      <h1>Daily Sketch Generator</h1>
      <p>Create daily postings with media, p5.js sketches, and HTML overlays</p>
      <hr />
    </header>

    <!-- Controls Panel -->
    <aside class="controls-panel">
      <div class="control-group">
        <label for="date-selector">Date (YYMMDD):</label>
        <input
          type="text"
          id="date-selector"
          placeholder="251111"
          maxlength="6"
        />
        <button id="load-date-btn">Load</button>
      </div>

      <div class="control-group">
        <label for="aspect-ratio">Aspect Ratio:</label>
        <select id="aspect-ratio">
          <option value="4:3">4:3</option>
          <option value="1:1" selected>1:1</option>
          <option value="9:16">9:16</option>
          <option value="custom">Custom</option>
        </select>
      </div>

      <div class="control-group" id="custom-dimensions" style="display: none;">
        <label for="custom-width">Width:</label>
        <input
          type="number"
          id="custom-width"
          value="800"
          min="100"
          max="4000"
        />
        <label for="custom-height">Height:</label>
        <input
          type="number"
          id="custom-height"
          value="800"
          min="100"
          max="4000"
        />
        <button id="apply-custom-btn">Apply</button>
      </div>

      <div class="control-group">
        <label>
          <input type="checkbox" id="toggle-background" checked /> Background Layer
        </label>
        <label>
          <input type="checkbox" id="toggle-p5" checked /> p5.js Sketch
        </label>
        <label>
          <input type="checkbox" id="toggle-overlay" checked /> HTML Overlay
        </label>
      </div>

      <div class="control-group">
        <label for="api-endpoint">API Endpoint:</label>
        <input
          type="text"
          id="api-endpoint"
          placeholder="https://api.example.com/data"
        />
        <button id="test-api-btn">Test</button>
      </div>

      <div class="control-group">
        <label for="overlay-text">Overlay Text:</label>
        <textarea
          id="overlay-text"
          rows="3"
          placeholder="Enter your post text here..."></textarea>
      </div>

      <div class="control-group export-group">
        <button id="export-svg-btn">Export SVG</button>
        <button id="export-image-btn">Export Image</button>
        <button id="export-video-btn">Export Video</button>
        <select id="video-duration">
          <option value="4">4 seconds</option>
          <option value="12" selected>12 seconds</option>
          <option value="custom">Custom</option>
        </select>
        <input
          type="number"
          id="custom-duration"
          value="12"
          min="1"
          max="60"
          style="display: none;"
        />
      </div>
    </aside>

    <!-- Canvas Container -->
    <section id="canvas-wrapper">
      <div id="canvas-container"></div>

      <!-- Background Layer -->
      <div id="background-layer">
        <img id="background-image" style="display: none;" />
        <video id="background-video" style="display: none;" autoplay loop muted
        ></video>
      </div>

      <!-- Middle Layer: p5.js -->
      <div id="p5-container"></div>

      <!-- Foreground Layer: HTML Overlay -->
      <div id="html-overlay">
        <div id="overlay-content">
          <div id="overlay-text-display"></div>
          <div id="api-data-display"></div>

          <h1>hello_world</h1>
        </div>
      </div>
    </section>
  </main>

  <style>
    /* main {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }

    .header {
      text-align: center;
      margin-bottom: 2rem;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }

    .controls-panel {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 0.5rem;
      padding: 1.5rem;
      margin-bottom: 2rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label {
      font-weight: 500;
      font-size: 0.875rem;
    }

    .control-group input[type="text"],
    .control-group input[type="number"],
    .control-group select,
    .control-group textarea {
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.25rem;
      font-size: 0.875rem;
    }

    .control-group button {
      padding: 0.5rem 1rem;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 0.25rem;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }

    .control-group button:hover {
      background: #1d4ed8;
    }

    .export-group {
      grid-column: 1 / -1;
      flex-direction: row;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
    }

    .export-group button {
      background: #059669;
    }

    .export-group button:hover {
      background: #047857;
    } */
    @reference "@/styles/tailwind--.css";

    #canvas-wrapper {
      position: relative;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      background: #000;
      border: 2px solid #e5e7eb;
      border-radius: 0.5rem;
      overflow: hidden;
    }

    #canvas-container {
      position: relative;
      width: 100%;
      padding-bottom: 100%; /* Default 1:1 */
    }

    #background-layer,
    #p5-container,
    #html-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #background-layer {
      z-index: 1;
    }

    #background-layer img,
    #background-layer video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #p5-container {
      z-index: 2;
      pointer-events: none;
    }

    #html-overlay {
      z-index: 3;
      pointer-events: none;
      color: white;
      font-family: sans-serif;
    }

    #background-layer {
        pointer-events: none;
    }
    #overlay-content {
      padding: 1rem;
      height: 100%;
      /* display: flex;
      flex-direction: column;
      justify-content: space-between; */
      @apply grid grid-cols-2 gap-4;

      h1 {
        color: red;
        @apply text-6xl;
      }
    }

    #overlay-text-display {
      font-size: 1.5rem;
      font-weight: 600;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
    }

    #api-data-display {
      font-size: 1rem;
      background: rgba(0, 0, 0, 0.6);
      padding: 0.75rem;
      border-radius: 0.25rem;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
    }
  </style>

  <!-- Libraries -->
  <script
    is:inline
    src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script
    is:inline
    src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"
  ></script>
  <script
    is:inline
    src="https://cdn.jsdelivr.net/npm/p5.js-svg@1.5.1/dist/p5.svg.min.js"
  ></script>

  <script is:inline>
    // Configuration
    const SUPPORTED_EXTENSIONS = [
      "png",
      "jpg",
      "jpeg",
      "gif",
      "webp",
      "mp4",
      "webm",
      "mp3",
    ];
    let CANVAS_WIDTH = 800;
    let CANVAS_HEIGHT = 800;
    let currentDate = getTodayDate();
    let p5Instance = null;
    let p5Canvas = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let compositeCanvas = null;
    let compositeCtx = null;
    let overlayCanvas = null;
    let overlayCtx = null;

    // State
    const state = {
      backgroundVisible: true,
      p5Visible: true,
      overlayVisible: true,
      aspectRatio: "1:1",
      apiEndpoint: "",
      overlayText: "",
      apiData: null,
    };

    // Initialize
    document.addEventListener("DOMContentLoaded", () => {
      setupEventListeners();
      updateDateSelector();
      loadMediaForDate(currentDate);
      initializeP5();
      startApiPolling();
    });

    // Get today's date in YYMMDD format
    function getTodayDate() {
      const now = new Date();
      const year = String(now.getFullYear()).slice(-2);
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const day = String(now.getDate()).padStart(2, "0");
      return year + month + day;
    }

    // Update date selector with today's date
    function updateDateSelector() {
      document.getElementById("date-selector").value = currentDate;
    }

    // Setup event listeners
    function setupEventListeners() {
      // Date selector
      document.getElementById("load-date-btn").addEventListener("click", () => {
        const dateInput = document.getElementById("date-selector").value;
        if (dateInput.length === 6 && /^\d{6}$/.test(dateInput)) {
          currentDate = dateInput;
          loadMediaForDate(currentDate);
        } else {
          alert("Please enter a valid date in YYMMDD format");
        }
      });

      // Aspect ratio selector
      document
        .getElementById("aspect-ratio")
        .addEventListener("change", (e) => {
          state.aspectRatio = e.target.value;
          if (e.target.value === "custom") {
            document.getElementById("custom-dimensions").style.display = "flex";
          } else {
            document.getElementById("custom-dimensions").style.display = "none";
            applyAspectRatio(e.target.value);
          }
        });

      // Custom dimensions
      document
        .getElementById("apply-custom-btn")
        .addEventListener("click", () => {
          const width = parseInt(document.getElementById("custom-width").value);
          const height = parseInt(
            document.getElementById("custom-height").value
          );
          if (width > 0 && height > 0) {
            CANVAS_WIDTH = width;
            CANVAS_HEIGHT = height;
            resizeCanvas();
          }
        });

      // Layer toggles
      document
        .getElementById("toggle-background")
        .addEventListener("change", (e) => {
          state.backgroundVisible = e.target.checked;
          document.getElementById("background-layer").style.display = e.target
            .checked
            ? "block"
            : "none";
        });

      document.getElementById("toggle-p5").addEventListener("change", (e) => {
        state.p5Visible = e.target.checked;
        document.getElementById("p5-container").style.display = e.target.checked
          ? "block"
          : "none";
        if (e.target.checked && p5Instance) {
          p5Instance.loop();
        } else if (p5Instance) {
          p5Instance.noLoop();
        }
      });

      document
        .getElementById("toggle-overlay")
        .addEventListener("change", (e) => {
          state.overlayVisible = e.target.checked;
          document.getElementById("html-overlay").style.display = e.target
            .checked
            ? "block"
            : "none";
        });

      // API endpoint
      document
        .getElementById("api-endpoint")
        .addEventListener("change", (e) => {
          state.apiEndpoint = e.target.value;
          if (state.apiEndpoint) {
            fetchApiData();
          }
        });

      document.getElementById("test-api-btn").addEventListener("click", () => {
        fetchApiData();
      });

      // Overlay text
      document.getElementById("overlay-text").addEventListener("input", (e) => {
        state.overlayText = e.target.value;
        document.getElementById("overlay-text-display").textContent =
          e.target.value;
      });

      // Video duration
      document
        .getElementById("video-duration")
        .addEventListener("change", (e) => {
          if (e.target.value === "custom") {
            document.getElementById("custom-duration").style.display =
              "inline-block";
          } else {
            document.getElementById("custom-duration").style.display = "none";
          }
        });

      // Export buttons
      document
        .getElementById("export-svg-btn")
        .addEventListener("click", exportSVG);
      document
        .getElementById("export-image-btn")
        .addEventListener("click", exportImage);
      document
        .getElementById("export-video-btn")
        .addEventListener("click", exportVideo);
    }

    // Apply aspect ratio
    function applyAspectRatio(ratio) {
      const baseWidth = 800;
      switch (ratio) {
        case "4:3":
          CANVAS_WIDTH = baseWidth;
          CANVAS_HEIGHT = (baseWidth * 3) / 4;
          break;
        case "1:1":
          CANVAS_WIDTH = baseWidth;
          CANVAS_HEIGHT = baseWidth;
          break;
        case "9:16":
          CANVAS_WIDTH = baseWidth;
          CANVAS_HEIGHT = (baseWidth * 16) / 9;
          break;
      }
      resizeCanvas();
    }

    // Resize canvas container
    function resizeCanvas() {
      const container = document.getElementById("canvas-container");
      const aspectRatio = CANVAS_HEIGHT / CANVAS_WIDTH;
      container.style.paddingBottom = `${aspectRatio * 100}%`;

      if (p5Instance && p5Canvas) {
        p5Instance.resizeCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
      }

      // Update composite canvas dimensions
      if (compositeCanvas) {
        compositeCanvas.width = CANVAS_WIDTH;
        compositeCanvas.height = CANVAS_HEIGHT;
      }
      if (overlayCanvas) {
        overlayCanvas.width = CANVAS_WIDTH;
        overlayCanvas.height = CANVAS_HEIGHT;
      }
    }

    // Load media for date
    async function loadMediaForDate(date) {
      const dailyPath = `/daily/`;
      let mediaFound = false;
      const imageEl = document.getElementById("background-image");
      const videoEl = document.getElementById("background-video");

      // Try to load each supported format
      for (const ext of SUPPORTED_EXTENSIONS) {
        const filename = `${date}.${ext}`;
        const testUrl = `${dailyPath}${filename}`;

        // For images, try loading directly
        if (["png", "jpg", "jpeg", "gif", "webp"].includes(ext)) {
          const img = new Image();
          img.onload = () => {
            mediaFound = true;
            loadMedia(testUrl, ext);
          };
          img.onerror = () => {
            // Continue to next format
          };
          img.src = testUrl;
          // Give it a moment to load
          await new Promise((resolve) => setTimeout(resolve, 100));
          if (img.complete && img.naturalWidth > 0) {
            mediaFound = true;
            loadMedia(testUrl, ext);
            break;
          }
        }
        // For videos, try HEAD request
        else if (["mp4", "webm"].includes(ext)) {
          try {
            const response = await fetch(testUrl, { method: "HEAD" });
            if (response.ok) {
              mediaFound = true;
              loadMedia(testUrl, ext);
              break;
            }
          } catch (error) {
            // Continue to next format
          }
        }
      }

      if (!mediaFound) {
        console.log(`No media found for date ${date} in /daily/`);
        imageEl.style.display = "none";
        videoEl.style.display = "none";
      }
    }

    // Load media file
    function loadMedia(url, extension) {
      const imageEl = document.getElementById("background-image");
      const videoEl = document.getElementById("background-video");

      if (["png", "jpg", "jpeg", "gif", "webp"].includes(extension)) {
        // Set crossorigin to avoid CORS issues
        imageEl.crossOrigin = "anonymous";
        imageEl.src = url;
        imageEl.style.display = "block";
        videoEl.style.display = "none";

        // Ensure image is loaded
        if (!imageEl.complete) {
          imageEl.onload = () => {
            console.log("Background image loaded:", url);
          };
          imageEl.onerror = () => {
            console.error("Failed to load background image:", url);
          };
        }
      } else if (["mp4", "webm"].includes(extension)) {
        videoEl.crossOrigin = "anonymous";
        videoEl.src = url;
        videoEl.style.display = "block";
        imageEl.style.display = "none";
        videoEl.load();

        videoEl.onloadeddata = () => {
          console.log("Background video loaded:", url);
        };
        videoEl.onerror = () => {
          console.error("Failed to load background video:", url);
        };
      }
    }

    // Initialize composite canvas for video recording
    function initializeCompositeCanvas() {
      compositeCanvas = document.createElement("canvas");
      compositeCanvas.width = CANVAS_WIDTH;
      compositeCanvas.height = CANVAS_HEIGHT;
      compositeCtx = compositeCanvas.getContext("2d");

      overlayCanvas = document.createElement("canvas");
      overlayCanvas.width = CANVAS_WIDTH;
      overlayCanvas.height = CANVAS_HEIGHT;
      overlayCtx = overlayCanvas.getContext("2d");
    }

    // Update overlay canvas from HTML element (async, call before recording)
    async function updateOverlayCanvas() {
      if (!overlayCanvas || !overlayCtx) return;

      try {
        const overlayElement = document.getElementById("html-overlay");
        const htmlCanvas = await html2canvas(overlayElement, {
          backgroundColor: null,
          width: CANVAS_WIDTH,
          height: CANVAS_HEIGHT,
          scale: 1,
          useCORS: true,
          allowTaint: false,
        });

        overlayCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        overlayCtx.drawImage(htmlCanvas, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      } catch (error) {
        console.error("Failed to update overlay canvas:", error);
      }
    }

    // Render all layers to composite canvas
    function renderToCompositeCanvas() {
      if (!compositeCanvas || !compositeCtx) return;

      // Clear canvas
      compositeCtx.fillStyle = "#000000";
      compositeCtx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

      // Draw background if visible
      if (state.backgroundVisible) {
        const bgImage = document.getElementById("background-image");
        const bgVideo = document.getElementById("background-video");

        if (
          bgImage.style.display !== "none" &&
          bgImage.complete &&
          bgImage.naturalWidth > 0
        ) {
          compositeCtx.drawImage(bgImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        } else if (
          bgVideo.style.display !== "none" &&
          bgVideo.readyState >= 2
        ) {
          compositeCtx.drawImage(bgVideo, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }
      }

      // Draw p5 canvas if visible
      if (state.p5Visible && p5Canvas && p5Canvas.elt) {
        compositeCtx.drawImage(p5Canvas.elt, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
      }

      // Draw HTML overlay if visible (from pre-rendered canvas)
      if (state.overlayVisible && overlayCanvas) {
        compositeCtx.drawImage(
          overlayCanvas,
          0,
          0,
          CANVAS_WIDTH,
          CANVAS_HEIGHT
        );
      }
    }

    // Initialize p5.js
    function initializeP5() {
      // Wait for p5 to be available
      if (typeof p5 === "undefined") {
        setTimeout(initializeP5, 100);
        return;
      }

      const sketch = (p) => {
        p.setup = () => {
          p5Canvas = p.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
          p5Canvas.parent("p5-container");
          p.noLoop();
        };

        p.draw = () => {
          p.background(0, 0, 0, 0); // Transparent background

          // Default animated Perlin noise pattern
          p.noiseSeed(42);
          const time = p.frameCount * 0.01;

          for (let x = 0; x < CANVAS_WIDTH; x += 20) {
            for (let y = 0; y < CANVAS_HEIGHT; y += 20) {
              const noiseVal = p.noise(x * 0.01, y * 0.01, time);
              const size = p.map(noiseVal, 0, 1, 5, 20);
              const alpha = p.map(noiseVal, 0, 1, 50, 200);

              p.fill(255, 255, 255, alpha);
              p.noStroke();
              p.ellipse(x, y, size, size);
            }
          }
        };
      };

      p5Instance = new p5(sketch);
      initializeCompositeCanvas();
    }

    // Fetch API data
    async function fetchApiData() {
      if (!state.apiEndpoint) {
        // Default: show time/date
        updateApiDisplay({
          time: new Date().toLocaleTimeString(),
          date: new Date().toLocaleDateString(),
        });
        return;
      }

      try {
        const response = await fetch(state.apiEndpoint);
        if (response.ok) {
          const data = await response.json();
          state.apiData = data;
          updateApiDisplay(data);
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (error) {
        console.error("API fetch error:", error);
        updateApiDisplay({ error: "Failed to fetch API data" });
      }
    }

    // Update API display
    function updateApiDisplay(data) {
      const display = document.getElementById("api-data-display");
      if (data.error) {
        display.textContent = `Error: ${data.error}`;
      } else {
        display.textContent = JSON.stringify(data, null, 2);
      }
    }

    // Start API polling
    function startApiPolling() {
      // Update time/date every second if no custom API
      setInterval(() => {
        if (!state.apiEndpoint) {
          fetchApiData();
        }
      }, 1000);

      // Poll custom API every 5 seconds
      setInterval(() => {
        if (state.apiEndpoint) {
          fetchApiData();
        }
      }, 5000);
    }

    // Export SVG
    function exportSVG() {
      if (typeof p5 === "undefined") {
        alert("p5.js not loaded yet. Please wait a moment and try again.");
        return;
      }

      const svgRenderer = (p) => {
        p.setup = () => {
          p.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT, p.SVG);
          p.noLoop();
          p.background(0, 0, 0, 0);

          // Draw the same pattern as main sketch
          p.noiseSeed(42);
          const time = 0; // Static for SVG export

          for (let x = 0; x < CANVAS_WIDTH; x += 20) {
            for (let y = 0; y < CANVAS_HEIGHT; y += 20) {
              const noiseVal = p.noise(x * 0.01, y * 0.01, time);
              const size = p.map(noiseVal, 0, 1, 5, 20);
              const alpha = p.map(noiseVal, 0, 1, 50, 200);

              p.fill(255, 255, 255, alpha);
              p.noStroke();
              p.ellipse(x, y, size, size);
            }
          }

          p.save(`daily-sketch-${currentDate}.svg`);
        };
      };

      new p5(svgRenderer);
    }

    // Export Image
    async function exportImage() {
      try {
        // Create final canvas
        const finalCanvas = document.createElement("canvas");
        finalCanvas.width = CANVAS_WIDTH;
        finalCanvas.height = CANVAS_HEIGHT;
        const ctx = finalCanvas.getContext("2d");

        // Fill with black background first
        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Draw background if visible - wait for image to load
        if (state.backgroundVisible) {
          const bgImage = document.getElementById("background-image");
          const bgVideo = document.getElementById("background-video");

          if (bgImage.style.display !== "none") {
            // Wait for image to load if not already loaded
            if (!bgImage.complete || bgImage.naturalWidth === 0) {
              await new Promise((resolve, reject) => {
                bgImage.onload = resolve;
                bgImage.onerror = reject;
                // Timeout after 5 seconds
                setTimeout(() => reject(new Error("Image load timeout")), 5000);
              });
            }

            if (bgImage.naturalWidth > 0) {
              ctx.drawImage(bgImage, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
          } else if (bgVideo.style.display !== "none") {
            // Wait for video to be ready
            if (bgVideo.readyState < 2) {
              await new Promise((resolve, reject) => {
                bgVideo.onloadeddata = resolve;
                bgVideo.onerror = reject;
                setTimeout(() => reject(new Error("Video load timeout")), 5000);
              });
            }

            if (bgVideo.readyState >= 2) {
              ctx.drawImage(bgVideo, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }
          }
        }

        // Draw p5 canvas if visible
        if (state.p5Visible && p5Canvas && p5Canvas.elt) {
          ctx.drawImage(p5Canvas.elt, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        // Draw HTML overlay if visible
        if (state.overlayVisible) {
          const overlayElement = document.getElementById("html-overlay");
          const overlayCanvas = await html2canvas(overlayElement, {
            backgroundColor: null,
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            scale: 1,
            useCORS: true,
            allowTaint: false,
          });
          ctx.drawImage(overlayCanvas, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        }

        // Download
        const link = document.createElement("a");
        link.download = `daily-sketch-${currentDate}.png`;
        link.href = finalCanvas.toDataURL("image/png");
        link.click();
      } catch (error) {
        console.error("Export error:", error);
        alert("Failed to export image: " + error.message);
      }
    }

    // Export Video
    async function exportVideo() {
      if (!compositeCanvas) {
        initializeCompositeCanvas();
      }

      const durationSelect = document.getElementById("video-duration");
      let duration = 12;

      if (durationSelect.value === "custom") {
        duration =
          parseInt(document.getElementById("custom-duration").value) || 12;
      } else {
        duration = parseInt(durationSelect.value);
      }

      try {
        // Pre-render overlay canvas before starting recording
        if (state.overlayVisible) {
          await updateOverlayCanvas();
        }

        // Resume p5 animation if paused
        if (p5Instance) {
          p5Instance.loop();
        }

        // Create a rendering loop that composites all layers
        const fps = 30;
        const frameInterval = 1000 / fps;
        let frameCount = 0;
        const totalFrames = duration * fps;

        // Get composite canvas stream
        const stream = compositeCanvas.captureStream(fps);

        // Try different MIME types for better compatibility
        let mimeType = "video/webm;codecs=vp9";
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = "video/webm;codecs=vp8";
        }
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = "video/webm";
        }

        mediaRecorder = new MediaRecorder(stream, { mimeType });

        recordedChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            recordedChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: mimeType });
          const url = URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.download = `daily-sketch-${currentDate}.webm`;
          link.href = url;
          link.click();
          URL.revokeObjectURL(url);

          // Stop p5 animation
          if (p5Instance) {
            p5Instance.noLoop();
          }
        };

        // Start recording
        mediaRecorder.start();

        // Show recording indicator
        const exportBtn = document.getElementById("export-video-btn");
        const originalText = exportBtn.textContent;
        exportBtn.textContent = `Recording... (${duration}s)`;
        exportBtn.disabled = true;

        // Rendering loop - composite all layers each frame
        const renderLoop = setInterval(() => {
          renderToCompositeCanvas();
          frameCount++;

          if (frameCount >= totalFrames) {
            clearInterval(renderLoop);
            mediaRecorder.stop();
            exportBtn.textContent = originalText;
            exportBtn.disabled = false;
          }
        }, frameInterval);

        // Fallback stop after duration
        setTimeout(
          () => {
            clearInterval(renderLoop);
            if (mediaRecorder.state === "recording") {
              mediaRecorder.stop();
            }
            exportBtn.textContent = originalText;
            exportBtn.disabled = false;
          },
          duration * 1000 + 1000
        ); // Add 1 second buffer
      } catch (error) {
        console.error("Video export error:", error);
        alert("Failed to export video: " + error.message);
      }
    }
  </script>
</Layout>
