---
import Layout from '@/layouts/Layout.astro';
---

<Layout title="p5.js Experiments">
  <main class="container mx-auto px-4 py-8">
    <h1 class="text-4xl font-bold text-center mb-8 text-gray-800">p5.js Creative Experiments</h1>
    
    <div class="max-w-4xl mx-auto">
      <p class="text-lg text-gray-600 text-center mb-12">
        A collection of interactive p5.js sketches exploring generative art, visual effects, and creative coding techniques.
      </p>

      <div class="grid gap-8">
        <!-- Experiment 1: Noise Effect -->
        <div class="bg-white rounded-lg shadow-lg p-6">
          <h2 class="text-2xl font-semibold mb-4 text-gray-800">Experiment 1: Noise Effect Boundary</h2>
          <p class="text-gray-600 mb-6">
            Creating elements filled with dynamic noise effects constrained within defined boundaries. 
            Click and drag to create new noise-filled shapes!
          </p>
          
          <div class="flex justify-center">
            <div id="noise-sketch" class="border-2 border-gray-300 rounded-lg"></div>
          </div>
          
          <div class="mt-4 text-sm text-gray-500 text-center">
            <p>Controls: Click and drag to create shapes • Press 'R' to reset • Press 'N' for new noise pattern</p>
          </div>
        </div>

        <!-- Future experiments placeholder -->
        <div class="bg-gray-50 rounded-lg shadow p-6 border-2 border-dashed border-gray-300">
          <h2 class="text-2xl font-semibold mb-4 text-gray-600">Future Experiments</h2>
          <p class="text-gray-500">More creative coding experiments coming soon...</p>
          <ul class="mt-4 text-gray-500 text-sm">
            <li>• Particle systems and physics simulations</li>
            <li>• Generative art patterns</li>
            <li>• Interactive audio visualizations</li>
            <li>• 3D graphics and animations</li>
          </ul>
        </div>
      </div>
    </div>
  </main>

  <script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <script is:inline>
    // @ts-nocheck
    // Noise Effect Boundary Experiment
    let noiseShapes = [];
    let currentShape = null;
    let noiseOffset = 0;
    let isDrawing = false;

    function setup() {
      let canvas = createCanvas(800, 600);
      canvas.parent('noise-sketch');
      background(240);
      noFill();
      strokeWeight(1);
    }

    function draw() {
      background(240, 240, 240, 20); // Slight fade effect
      
      // Update and draw all completed shapes
      for (let shape of noiseShapes) {
        drawNoiseShape(shape);
      }
      
      // Draw current shape being created
      if (currentShape && currentShape.points.length > 1) {
        drawNoiseShape(currentShape);
      }
      
      noiseOffset += 0.001;
    }

    function drawNoiseShape(shape) {
      if (shape.points.length < 2) return;
      
      // Create boundary path
      stroke(100, 100, 100, 150);
      strokeWeight(2);
      noFill();
      beginShape();
      for (let point of shape.points) {
        vertex(point.x, point.y);
      }
      endShape();
      
      // Fill with noise effect
      let bounds = getBounds(shape.points);
      let density = 3; // Distance between noise points
      
      for (let x = bounds.minX; x <= bounds.maxX; x += density) {
        for (let y = bounds.minY; y <= bounds.maxY; y += density) {
          if (isPointInPolygon(x, y, shape.points)) {
            // Create noise-based color and movement
            let noiseVal = noise(x * 0.01, y * 0.01, noiseOffset + shape.seed);
            let alpha = map(noiseVal, 0, 1, 0, 255);
            
            // Color based on position and noise
            let r = map(noiseVal, 0, 1, 50, 255);
            let g = map(x, bounds.minX, bounds.maxX, 100, 200);
            let b = map(y, bounds.minY, bounds.maxY, 150, 255);
            
            stroke(r, g, b, alpha);
            strokeWeight(map(noiseVal, 0, 1, 0.5, 3));
            
            // Add slight movement based on noise
            let offsetX = map(noise(x * 0.02, noiseOffset), 0, 1, -2, 2);
            let offsetY = map(noise(y * 0.02, noiseOffset), 0, 1, -2, 2);
            
            point(x + offsetX, y + offsetY);
          }
        }
      }
    }

    function mousePressed() {
      if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
        isDrawing = true;
        currentShape = {
          points: [{x: mouseX, y: mouseY}],
          seed: random(1000)
        };
      }
    }

    function mouseDragged() {
      if (isDrawing && currentShape) {
        // Add point if far enough from last point
        let lastPoint = currentShape.points[currentShape.points.length - 1];
        let distance = dist(mouseX, mouseY, lastPoint.x, lastPoint.y);
        if (distance > 10) {
          currentShape.points.push({x: mouseX, y: mouseY});
        }
      }
    }

    function mouseReleased() {
      if (isDrawing && currentShape && currentShape.points.length > 2) {
        // Close the shape and add to completed shapes
        noiseShapes.push(currentShape);
      }
      currentShape = null;
      isDrawing = false;
    }

    function keyPressed() {
      if (key === 'r' || key === 'R') {
        // Reset all shapes
        noiseShapes = [];
        background(240);
      } else if (key === 'n' || key === 'N') {
        // New noise pattern - update seeds
        for (let shape of noiseShapes) {
          shape.seed = random(1000);
        }
      }
    }

    // Helper function to get bounding box of points
    function getBounds(points) {
      let minX = Math.min(...points.map(p => p.x));
      let maxX = Math.max(...points.map(p => p.x));
      let minY = Math.min(...points.map(p => p.y));
      let maxY = Math.max(...points.map(p => p.y));
      return {minX, maxX, minY, maxY};
    }

    // Helper function to check if point is inside polygon
    function isPointInPolygon(x, y, polygon) {
      let inside = false;
      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        if (((polygon[i].y > y) !== (polygon[j].y > y)) &&
            (x < (polygon[j].x - polygon[i].x) * (y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
          inside = !inside;
        }
      }
      return inside;
    }
  </script>

  <style>
    #noise-sketch {
      cursor: crosshair;
    }
    
    #noise-sketch:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: box-shadow 0.3s ease;
    }
  </style>
</Layout>