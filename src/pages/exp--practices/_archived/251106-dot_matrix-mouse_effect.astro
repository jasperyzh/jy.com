---
import Layout from "@/layouts/Layout.astro";
---

<Layout title="Dot Matrix Base">
  <main class="container">
    <div class="header">
      <h1>Dot Matrix Perlin Noise</h1>
      <p>
        Animated grayscale Perlin noise on a simulated 128x64 dot matrix
        display.
      </p>
    </div>
    <div id="canvas-container"></div>
    <div class="CONTROL-grid"></div>
  </main>
</Layout>
<script is:inline type="module">
  import "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js";
  import "https://cdn.jsdelivr.net/npm/p5.js-svg@1.5.1/dist/p5.svg.min.js";
</script>
<script is:inline type="module">
  import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";
  import PixelDisplay from "/dailies/PixelDisplay.js";

  const GR__ = 1.618;
  const MATRIX_SIZES = [64, 32, 16, 8, 4];
  let PIXEL_SCALE;
  let PIXEL_GAP;
  let MATRIX_WIDTH;
  let MATRIX_HEIGHT;

  // todo--
  // - [ ] transform the scale of each dots according to data

  let display;
  let zOffset = 0;

  const colorThemes = {
    "2a": { off: [13, 13, 13], on: [204, 165, 69], stroke: [13, 13, 13] },
    milk: { off: [227, 237, 239], on: [13, 13, 13], stroke: [13, 13, 13] },
    green: { off: [13, 13, 13], on: [100, 255, 100], stroke: [150, 255, 150] },
    amber: { off: [40, 20, 0], on: [255, 180, 0], stroke: [255, 200, 100] },
    white: { off: [40, 40, 40], on: [220, 220, 220], stroke: [255, 255, 255] },
    blue: { off: [10, 20, 40], on: [80, 160, 255], stroke: [120, 180, 255] },
  };

  const CONTROL = {
    matrixSize: 32,
    theme: "milk",
    noiseScale: 0.05,
    animationSpeed: 0.002,
    shadeSteps: 2,
    dotScaleFactor: 1.0,
    dotNoiseInfluence: 1.0,
    useColorThemeShading: true,
    // Mouse interaction controls
    mouseEffectEnabled: true,
    mouseEffectRadius: 150,
    mouseEffectIntensity: 2.5,
    mouseGlowEnabled: true,
    clickShockwaveEnabled: true,
    shockwaveRadius: 200,
    shockwavePower: 50,
    isAnimationPaused: false,
    logOledData: () => logOledData(),
    exportSvg: () => exportSvg(),
  };

  // Mouse tracking
  let mousePos = { x: -1000, y: -1000 };
  let shockwaves = [];

  function resetSketch() {
    MATRIX_WIDTH = Number(CONTROL.matrixSize);
    MATRIX_HEIGHT = Number(CONTROL.matrixSize);
    PIXEL_SCALE = 512 / MATRIX_WIDTH;
    PIXEL_GAP = PIXEL_SCALE - PIXEL_SCALE / Math.pow(GR__, 1);

    resizeCanvas(
      MATRIX_WIDTH * PIXEL_SCALE,
      MATRIX_HEIGHT * PIXEL_SCALE
    );

    display = new PixelDisplay(
      MATRIX_WIDTH,
      MATRIX_HEIGHT,
      PIXEL_SCALE,
      PIXEL_GAP
    );
    updateColorTheme();
  }

  window.setup = function () {
    MATRIX_WIDTH = Number(CONTROL.matrixSize);
    MATRIX_HEIGHT = Number(CONTROL.matrixSize);
    PIXEL_SCALE = 512 / MATRIX_WIDTH;
    PIXEL_GAP = PIXEL_SCALE - PIXEL_SCALE / Math.pow(GR__, 0);

    const canvas = createCanvas(
      MATRIX_WIDTH * PIXEL_SCALE,
      MATRIX_HEIGHT * PIXEL_SCALE
    );
    canvas.parent("canvas-container");

    display = new PixelDisplay(
      MATRIX_WIDTH,
      MATRIX_HEIGHT,
      PIXEL_SCALE,
      PIXEL_GAP
    );
    updateColorTheme();

    // Setup mouse event listeners
    canvas.mouseMoved(() => {
      mousePos.x = mouseX;
      mousePos.y = mouseY;
    });
    
    canvas.mousePressed(() => {
      if (CONTROL.clickShockwaveEnabled) {
        shockwaves.push({
          x: mouseX,
          y: mouseY,
          time: millis(),
          duration: 1000
        });
      }
    });

    const gui = new GUI();
    gui.add(CONTROL, 'matrixSize', MATRIX_SIZES).name('Matrix Size').onChange(resetSketch);
    gui
      .add(CONTROL, "theme", Object.keys(colorThemes))
      .name("Theme")
      .onChange(updateColorTheme);
    
    const noiseFolder = gui.addFolder("Noise Settings");
    noiseFolder.add(CONTROL, "noiseScale", 0.01, 0.8, 0.005).name("Noise Scale");
    noiseFolder.add(CONTROL, "animationSpeed", 0, 0.05, 0.001).name("Animation Speed");
    
    const dotFolder = gui.addFolder("Dot Settings");
    dotFolder.add(CONTROL, "shadeSteps", 2, 16, 1).name("Shade Steps");
    dotFolder.add(CONTROL, "dotScaleFactor", 0.1, 5.0, 0.05).name("Dot Scale Factor");
    dotFolder.add(CONTROL, "dotNoiseInfluence", 0.0, 3.0, 0.05).name("Dot Noise Influence");
    dotFolder.add(CONTROL, "useColorThemeShading").name("Use Color Theme Shading");
    
    const mouseFolder = gui.addFolder("Mouse Effects");
    mouseFolder.add(CONTROL, "mouseEffectEnabled").name("Enable Mouse Effect");
    mouseFolder.add(CONTROL, "mouseEffectRadius", 50, 300, 5).name("Effect Radius");
    mouseFolder.add(CONTROL, "mouseEffectIntensity", 1.0, 5.0, 0.1).name("Zoom Intensity");
    mouseFolder.add(CONTROL, "mouseGlowEnabled").name("Enable Glow");
    mouseFolder.add(CONTROL, "clickShockwaveEnabled").name("Enable Click Shockwave");
    mouseFolder.add(CONTROL, "shockwaveRadius", 50, 400, 10).name("Shockwave Radius");
    mouseFolder.add(CONTROL, "shockwavePower", 10, 100, 5).name("Shockwave Power");
    
    gui
      .add(CONTROL, "isAnimationPaused")
      .name("Pause Animation")
      .onChange(toggleAnimation);
    gui.add(CONTROL, "logOledData").name("Log OLED Data");
    gui.add(CONTROL, "exportSvg").name("Export SVG");
  };

  window.draw = function () {
    background(colorThemes[CONTROL.theme].off);

    push();
    translate(1, 1);
    display.clear();

    // Update shockwaves
    const currentTime = millis();
    shockwaves = shockwaves.filter(wave => currentTime - wave.time < wave.duration);

    for (let y = 0; y < display.matrixHeight; y++) {
      for (let x = 0; x < display.matrixWidth; x++) {
        const noiseVal = noise(
          x * CONTROL.noiseScale,
          y * CONTROL.noiseScale,
          zOffset
        );
        display.setPixel(x, y, noiseVal);
      }
    }

    zOffset += CONTROL.animationSpeed;
    
    // Render with mouse effects
    renderWithMouseEffects();
    pop();
  };

  function renderWithMouseEffects() {
    display.buffer.background(display.colorOff);
    display.buffer.noStroke();
    display.buffer.ellipseMode(CORNER);

    for (let px = 0; px < display.matrixWidth; px++) {
      for (let py = 0; py < display.matrixHeight; py++) {
        const noiseVal = display.pixelMatrix[px][py];
        if (noiseVal === 0) continue;

        // Calculate pixel center position in canvas coordinates
        const pixelCenterX = px * display.pixelScale + display.pixelScale / 2 + 1;
        const pixelCenterY = py * display.pixelScale + display.pixelScale / 2 + 1;

        // Calculate distance to mouse
        const distToMouse = dist(pixelCenterX, pixelCenterY, mousePos.x, mousePos.y);
        
        // Calculate mouse effect
        let mouseScale = 1.0;
        let glowFactor = 0;
        
        if (CONTROL.mouseEffectEnabled && distToMouse < CONTROL.mouseEffectRadius) {
          const normalizedDist = distToMouse / CONTROL.mouseEffectRadius;
          const effectStrength = 1 - normalizedDist;
          mouseScale = 1 + (effectStrength * (CONTROL.mouseEffectIntensity - 1));
          
          if (CONTROL.mouseGlowEnabled) {
            glowFactor = effectStrength;
          }
        }

        // Calculate shockwave effects
        let shockwaveOffset = { x: 0, y: 0 };
        shockwaves.forEach(wave => {
          const elapsed = millis() - wave.time;
          const progress = elapsed / wave.duration;
          const waveX = wave.x;
          const waveY = wave.y;
          const distToWave = dist(pixelCenterX, pixelCenterY, waveX, waveY);
          
          if (distToWave < CONTROL.shockwaveRadius) {
            const normalizedDist = distToWave / CONTROL.shockwaveRadius;
            const ripple = sin(progress * PI * 4 - normalizedDist * PI * 2);
            const falloff = (1 - normalizedDist) * (1 - progress);
            const pushStrength = ripple * falloff * CONTROL.shockwavePower;
            
            const angle = atan2(pixelCenterY - waveY, pixelCenterX - waveX);
            shockwaveOffset.x += cos(angle) * pushStrength;
            shockwaveOffset.y += sin(angle) * pushStrength;
          }
        });

        // Determine pixel color with glow
        let pixelColor;
        if (!CONTROL.useColorThemeShading) {
          pixelColor = display.colorOn;
        } else {
          const shadeValue = floor(map(noiseVal, 0, 1, 0, CONTROL.shadeSteps));
          if (shadeValue === 0) continue;
          const amount = shadeValue / (CONTROL.shadeSteps - 1);
          pixelColor = lerpColor(display.colorOff, display.colorOn, amount);
        }
        
        // Apply glow effect by brightening the color
        if (glowFactor > 0) {
          pixelColor = lerpColor(pixelColor, display.colorOn, glowFactor * 0.7);
        }
        
        display.buffer.fill(pixelColor);

        // Calculate dot size with mouse scaling
        const baseDotSize = display.pixelScale - display.pixelGap;
        const maxDotSize = baseDotSize * CONTROL.dotScaleFactor;
        const minDotSize = lerp(maxDotSize, 0, CONTROL.dotNoiseInfluence);
        let scaledDotSize = map(noiseVal, 0, 1, minDotSize, maxDotSize);
        
        // Apply mouse effect scaling
        scaledDotSize *= mouseScale;
        
        const offset = (display.pixelScale - scaledDotSize) / 2;

        // Draw dot with shockwave offset
        display.buffer.ellipse(
          px * display.pixelScale + offset + shockwaveOffset.x,
          py * display.pixelScale + offset + shockwaveOffset.y,
          scaledDotSize,
          scaledDotSize
        );
      }
    }
    
    image(display.buffer, 0, 0);
  }

  function updateColorTheme() {
    const theme = colorThemes[CONTROL.theme];
    display.setColors(
      color(...theme.off),
      color(...theme.on),
      color(...theme.stroke)
    );
  }

  function toggleAnimation() {
    if (CONTROL.isAnimationPaused) {
      noLoop();
    } else {
      loop();
    }
  }

  function logOledData() {
    const pageCount = display.matrixHeight / 8;
    const bufferSize = display.matrixWidth * pageCount;
    const oledBuffer = new Uint8Array(bufferSize);

    for (let page = 0; page < pageCount; page++) {
      for (let x = 0; x < display.matrixWidth; x++) {
        let byte = 0;
        for (let bit = 0; bit < 8; bit++) {
          const y = page * 8 + bit;
          if (display.pixelMatrix[x][y] > 0) {
            byte |= 1 << bit;
          }
        }
        oledBuffer[page * display.matrixWidth + x] = byte;
      }
    }
    console.log(`SH1106-compatible data buffer (threshold > 0):`, oledBuffer);
  }

  function exportSvg() {
    const svgRenderer = (p) => {
      p.setup = () => {
        p.createCanvas(
          display.matrixWidth * display.pixelScale,
          display.matrixHeight * display.pixelScale,
          p.SVG
        );
        p.noLoop();
        p.background(display.colorOff);
        p.noStroke();

        for (let x = 0; x < display.matrixWidth; x++) {
          for (let y = 0; y < display.matrixHeight; y++) {
            const noiseVal = display.pixelMatrix[x][y];
            if (noiseVal === 0) continue;

            let pixelColor;
            if (!CONTROL.useColorThemeShading) {
              pixelColor = display.colorOn;
            } else {
              const shadeValue = floor(map(noiseVal, 0, 1, 0, CONTROL.shadeSteps));
              if (shadeValue === 0) continue;
              const amount = (shadeValue) / (CONTROL.shadeSteps - 1);
              pixelColor = lerpColor(
                display.colorOff,
                display.colorOn,
                amount
              );
            }

            p.fill(pixelColor);

            const baseDotSize = display.pixelScale - display.pixelGap;
            const maxDotSize = baseDotSize * CONTROL.dotScaleFactor;
            const minDotSize = lerp(maxDotSize, 0, CONTROL.dotNoiseInfluence);
            const scaledDotSize = map(noiseVal, 0, 1, minDotSize, maxDotSize);
            const offset = (display.pixelScale - scaledDotSize) / 2;

            p.ellipseMode(CORNER);
            p.ellipse(
              x * display.pixelScale + offset,
              y * display.pixelScale + offset,
              scaledDotSize,
              scaledDotSize
            );
          }
        }
        p.save("dot-matrix-perlin-noise.svg");
      };
    };
    new p5(svgRenderer);
  }
</script>
