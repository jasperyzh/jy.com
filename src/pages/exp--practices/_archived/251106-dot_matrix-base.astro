---
import Layout from "@/layouts/Layout.astro";
---

<Layout title="Dot Matrix Base">
  <main class="container">
    <div class="header">
      <h1>Dot Matrix Perlin Noise</h1>
      <p>
        Animated grayscale Perlin noise on a simulated 128x64 dot matrix
        display.
      </p>
    </div>
    <div id="canvas-container"></div>
    <div class="CONTROL-grid"></div>
  </main>
</Layout>
<script is:inline type="module">
  import "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js";
  import "https://cdn.jsdelivr.net/npm/p5.js-svg@1.5.1/dist/p5.svg.min.js";
</script>
<script is:inline type="module">
  import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";
  import PixelDisplay from "/dailies/PixelDisplay.js";

  const GR__ = 1.618;
  const MATRIX_SIZES = [64, 32, 16, 8, 4];
  let PIXEL_SCALE;
  let PIXEL_GAP;
  let MATRIX_WIDTH;
  let MATRIX_HEIGHT;

  // todo--
  // - [ ] transform the scale of each dots according to data

  let display;
  let zOffset = 0;

  const colorThemes = {
    "2a": { off: [13, 13, 13], on: [204, 165, 69], stroke: [13, 13, 13] },
    milk: { off: [227, 237, 239], on: [13, 13, 13], stroke: [13, 13, 13] },
    green: { off: [13, 13, 13], on: [100, 255, 100], stroke: [150, 255, 150] },
    amber: { off: [40, 20, 0], on: [255, 180, 0], stroke: [255, 200, 100] },
    white: { off: [40, 40, 40], on: [220, 220, 220], stroke: [255, 255, 255] },
    blue: { off: [10, 20, 40], on: [80, 160, 255], stroke: [120, 180, 255] },
  };

  const CONTROL = {
    matrixSize: 32,
    theme: "milk",
    noiseScale: 0.05,
    animationSpeed: 0.002,
    shadeSteps: 2,
    dotScaleFactor: 1.0, // New control for dot scaling
    dotNoiseInfluence: 1.0, // New control for dot size influence by noise
    useColorThemeShading: true, // New control for color theme shading
    isAnimationPaused: false,
    logOledData: () => logOledData(),
    exportSvg: () => exportSvg(),
  };

  function resetSketch() {
    MATRIX_WIDTH = Number(CONTROL.matrixSize);
    MATRIX_HEIGHT = Number(CONTROL.matrixSize);
    PIXEL_SCALE = 512 / MATRIX_WIDTH;
    PIXEL_GAP = PIXEL_SCALE - PIXEL_SCALE / Math.pow(GR__, 1);

    resizeCanvas(
      MATRIX_WIDTH * PIXEL_SCALE,
      MATRIX_HEIGHT * PIXEL_SCALE
    );

    display = new PixelDisplay(
      MATRIX_WIDTH,
      MATRIX_HEIGHT,
      PIXEL_SCALE,
      PIXEL_GAP
    );
    updateColorTheme();
  }

  window.setup = function () {
    MATRIX_WIDTH = Number(CONTROL.matrixSize);
    MATRIX_HEIGHT = Number(CONTROL.matrixSize);
    PIXEL_SCALE = 512 / MATRIX_WIDTH;
    PIXEL_GAP = PIXEL_SCALE - PIXEL_SCALE / Math.pow(GR__, 0);

    const canvas = createCanvas(
      MATRIX_WIDTH * PIXEL_SCALE,
      MATRIX_HEIGHT * PIXEL_SCALE
    );
    canvas.parent("canvas-container");

    display = new PixelDisplay(
      MATRIX_WIDTH,
      MATRIX_HEIGHT,
      PIXEL_SCALE,
      PIXEL_GAP
    );
    updateColorTheme();

    const gui = new GUI();
    gui.add(CONTROL, 'matrixSize', MATRIX_SIZES).name('Matrix Size').onChange(resetSketch);
    gui
      .add(CONTROL, "theme", Object.keys(colorThemes))
      .name("Theme")
      .onChange(updateColorTheme);
    gui.add(CONTROL, "noiseScale", 0.01, 0.8, 0.005).name("Noise Scale");
    gui.add(CONTROL, "animationSpeed", 0, 0.05, 0.001).name("Animation Speed");
    gui.add(CONTROL, "shadeSteps", 2, 16, 1).name("Shade Steps");
    gui.add(CONTROL, "dotScaleFactor", 0.1, 5.0, 0.05).name("Dot Scale Factor");
    gui.add(CONTROL, "dotNoiseInfluence", 0.0, 3.0, 0.05).name("Dot Noise Influence");
    gui.add(CONTROL, "useColorThemeShading").name("Use Color Theme Shading");
    gui
      .add(CONTROL, "isAnimationPaused")
      .name("Pause Animation")
      .onChange(toggleAnimation);
    gui.add(CONTROL, "logOledData").name("Log OLED Data");
    gui.add(CONTROL, "exportSvg").name("Export SVG");
  };

  window.draw = function () {
    background(colorThemes[CONTROL.theme].off);

    push();
    translate(1, 1);
    display.clear();

    for (let y = 0; y < display.matrixHeight; y++) {
      for (let x = 0; x < display.matrixWidth; x++) {
        const noiseVal = noise(
          x * CONTROL.noiseScale,
          y * CONTROL.noiseScale,
          zOffset
        );
        display.setPixel(x, y, noiseVal);
      }
    }

    zOffset += CONTROL.animationSpeed;
    display.render(0, 0, CONTROL);
    pop();
  };

  function updateColorTheme() {
    const theme = colorThemes[CONTROL.theme];
    display.setColors(
      color(...theme.off),
      color(...theme.on),
      color(...theme.stroke)
    );
  }

  function toggleAnimation() {
    if (CONTROL.isAnimationPaused) {
      noLoop();
    } else {
      loop();
    }
  }

  function logOledData() {
    const pageCount = display.matrixHeight / 8;
    const bufferSize = display.matrixWidth * pageCount;
    const oledBuffer = new Uint8Array(bufferSize);

    for (let page = 0; page < pageCount; page++) {
      for (let x = 0; x < display.matrixWidth; x++) {
        let byte = 0;
        for (let bit = 0; bit < 8; bit++) {
          const y = page * 8 + bit;
          if (display.pixelMatrix[x][y] > 0) {
            byte |= 1 << bit;
          }
        }
        oledBuffer[page * display.matrixWidth + x] = byte;
      }
    }
    console.log(`SH1106-compatible data buffer (threshold > 0):`, oledBuffer);
  }

  function exportSvg() {
    const svgRenderer = (p) => {
      p.setup = () => {
        p.createCanvas(
          display.matrixWidth * display.pixelScale,
          display.matrixHeight * display.pixelScale,
          p.SVG
        );
        p.noLoop();
        p.background(display.colorOff);
        p.noStroke();

        for (let x = 0; x < display.matrixWidth; x++) {
          for (let y = 0; y < display.matrixHeight; y++) {
            const noiseVal = display.pixelMatrix[x][y];
            if (noiseVal === 0) continue;

            let pixelColor;
            if (!CONTROL.useColorThemeShading) {
              pixelColor = display.colorOn;
            } else {
              const shadeValue = floor(map(noiseVal, 0, 1, 0, CONTROL.shadeSteps));
              if (shadeValue === 0) continue;
              const amount = (shadeValue) / (CONTROL.shadeSteps - 1);
              pixelColor = lerpColor(
                display.colorOff,
                display.colorOn,
                amount
              );
            }

            p.fill(pixelColor);

            const baseDotSize = display.pixelScale - display.pixelGap;
            const maxDotSize = baseDotSize * CONTROL.dotScaleFactor;
            const minDotSize = lerp(maxDotSize, 0, CONTROL.dotNoiseInfluence);
            const scaledDotSize = map(noiseVal, 0, 1, minDotSize, maxDotSize);
            const offset = (display.pixelScale - scaledDotSize) / 2;

            p.ellipseMode(CORNER);
            p.ellipse(
              x * display.pixelScale + offset,
              y * display.pixelScale + offset,
              scaledDotSize,
              scaledDotSize
            );
          }
        }
        p.save("dot-matrix-perlin-noise.svg");
      };
    };
    new p5(svgRenderer);
  }
</script>
