---
import Layout from "@/layouts/Layout.astro";
---

<Layout title="Daily Sketch 251119">
    <main
        class="min-h-screen bg-neutral-900 flex items-center justify-center p-8"
    >
        <!-- Main Container -->
        <div class="flex flex-col gap-4 w-full max-w-[1200px]">
            <!-- Header / Controls -->
            <header class="flex justify-between items-center text-neutral-400">
                <h1 class="text-xl font-mono">251119_DAILY_SKETCH</h1>
                <div class="flex gap-2">
                    <button
                        id="btn-export-svg"
                        class="px-3 py-1 border border-neutral-700 hover:bg-neutral-800 rounded text-sm transition-colors cursor-pointer"
                        >Export SVG</button
                    >
                    <button
                        id="btn-export-png"
                        class="px-3 py-1 border border-neutral-700 hover:bg-neutral-800 rounded text-sm transition-colors cursor-pointer"
                        >Export PNG</button
                    >
                    <button
                        id="btn-record"
                        class="px-3 py-1 border border-neutral-700 hover:bg-neutral-800 rounded text-sm transition-colors cursor-pointer text-red-500"
                        >Record Video</button
                    >
                </div>
            </header>

            <!-- Sketch Frame (The Capture Area) -->
            <div
                id="sketch-frame"
                class="relative mx-auto bg-white overflow-hidden shadow-2xl"
                style="width: 800px; height: 800px;"
            >
                <!-- Layer 1: p5.js Canvas (Background) -->
                <div id="canvas-container" class="absolute inset-0 z-0"></div>

                <!-- Layer 2: HTML Overlay (Foreground) -->
                <div
                    id="html-overlay"
                    class="absolute inset-0 z-10 p-8 flex flex-col justify-between pointer-events-none --mix-blend-difference text-black fw-bold text-2xl"
                >
                    <!-- Top Bar -->
                    <div
                        class="flex justify-between items-start font-mono text-2xl uppercase tracking-widest"
                    >
                        <div class="flex flex-col gap-1">
                            <span id="data-location">LOADING...</span>
                            <span id="data-coords" class="text-xs opacity-50"
                                >--°N --°E</span
                            >
                        </div>
                        <div class="text-right">
                            <span id="data-time">00:00:00</span>
                        </div>
                    </div>

                    <!-- Center Content (Optional) -->
                    <div class="flex-1 flex items-center justify-center">
                        <!-- <h2 class="text-6xl font-bold opacity-20">VOID</h2> -->
                    </div>

                    <!-- Bottom Bar -->
                    <div
                        class="flex justify-between items-end font-mono text-2xl"
                    >
                        <div class="flex flex-col gap-1">
                            <span class="text-xs opacity-50">TEMP</span>
                            <span id="data-temp" class="text-2xl">--°C</span>
                        </div>
                        <div class="flex flex-col gap-1 text-right">
                            <span class="text-xs opacity-50">WIND</span>
                            <span id="data-wind">-- km/h</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footer -->
            <footer class="text-center text-neutral-600 text-xs font-mono mt-4">
                FRAMEWORK_V1 // OPEN-METEO API // P5.JS
            </footer>
        </div>
    </main>
</Layout>

<!-- Libraries -->
<script
    is:inline
    src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.10/p5.js"></script>
<script
    is:inline
    src="https://cdn.jsdelivr.net/npm/p5.js-svg@1.6.0/dist/p5.svg.min.js"
></script>

<script
    is:inline
    src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"
></script>

<script>
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";

    // --- CONFIGURATION ---
    const CONFIG = {
        debug: true,
        city: "Tokyo", // Default city
        lat: 35.6895,
        lon: 139.6917,
        refreshRate: 1000 * 60 * 15, // 15 mins

        // Dimensions
        width: 800,
        height: 800,

        // Sketch Params
        gridSize: 20,
        noiseScale: 0.05,
        dotSize: 0.8,
        animSpeed: 0.01,
        isPaused: false,

        // Export
        exportSize: "current", // 'current' | 'a4'
    };

    // --- STATE ---
    let weatherData = null;
    let p5Instance = null;

    // --- DOM ELEMENTS ---
    const els = {
        location: document.getElementById("data-location"),
        coords: document.getElementById("data-coords"),
        time: document.getElementById("data-time"),
        temp: document.getElementById("data-temp"),
        wind: document.getElementById("data-wind"),
        frame: document.getElementById("sketch-frame"),
    };

    // --- DATA LAYER ---
    async function fetchWeather() {
        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${CONFIG.lat}&longitude=${CONFIG.lon}&current=temperature_2m,wind_speed_10m&timezone=auto`;
            const res = await fetch(url);
            const data = await res.json();

            if (data.current) {
                weatherData = data.current;
                updateUI();
            }
        } catch (e) {
            console.error("Weather fetch failed", e);
        }
    }

    function updateUI() {
        if (!weatherData) return;
        els.location.textContent = CONFIG.city.toUpperCase();
        els.coords.textContent = `${CONFIG.lat.toFixed(2)}°N ${CONFIG.lon.toFixed(2)}°E`;
        els.temp.textContent = `${weatherData.temperature_2m}${weatherData.temperature_2m_unit || "°C"}`;
        els.wind.textContent = `${weatherData.wind_speed_10m} km/h`;
    }

    function updateTime() {
        const now = new Date();
        els.time.textContent = now.toLocaleTimeString("en-US", {
            hour12: false,
        });
    }

    // --- LAYOUT CONTROL ---
    function updateLayout() {
        els.frame.style.width = `${CONFIG.width}px`;
        els.frame.style.height = `${CONFIG.height}px`;
        if (p5Instance) {
            p5Instance.resizeCanvas(CONFIG.width, CONFIG.height);
        }
    }

    // --- P5 SKETCH ---
    const sketch = (p) => {
        let zOff = 0;

        p.setup = () => {
            // Initial create with config dimensions
            p.createCanvas(CONFIG.width, CONFIG.height);
            p.noStroke();
        };

        p.draw = () => {
            if (CONFIG.isPaused) return;

            p.background(255);
            p.fill(0);

            const cols = Math.floor(p.width / CONFIG.gridSize);
            const rows = Math.floor(p.height / CONFIG.gridSize);

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const x = i * CONFIG.gridSize;
                    const y = j * CONFIG.gridSize;

                    // Noise based on position and time
                    const n = p.noise(
                        i * CONFIG.noiseScale,
                        j * CONFIG.noiseScale,
                        zOff,
                    );

                    // Map noise to circle size
                    const d = CONFIG.gridSize * CONFIG.dotSize * n;

                    // Center the dot
                    const cx = x + CONFIG.gridSize / 2;
                    const cy = y + CONFIG.gridSize / 2;

                    p.circle(cx, cy, d);
                }
            }

            zOff += CONFIG.animSpeed;
        };
    };

    // --- EXPORT FUNCTIONS ---

    // SVG Export
    function exportSVG() {
        // Based on 251106 reference: Do not use a container, let p5 handle it.
        // We will remove the created SVG element manually after save.

        const svgSketch = (p) => {
            p.setup = () => {
                let w, h;

                if (CONFIG.exportSize === "a4") {
                    w = 794;
                    h = 1123;
                } else {
                    w = CONFIG.width;
                    h = CONFIG.height;
                }

                p.createCanvas(w, h, p.SVG);
                p.noLoop();

                p.background(255);
                p.fill(0);
                p.noStroke();

                const cols = Math.floor(w / CONFIG.gridSize);
                const rows = Math.floor(h / CONFIG.gridSize);

                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const x = i * CONFIG.gridSize;
                        const y = j * CONFIG.gridSize;
                        const n = p.noise(
                            i * CONFIG.noiseScale,
                            j * CONFIG.noiseScale,
                            0,
                        );
                        const d = CONFIG.gridSize * CONFIG.dotSize * n;
                        p.circle(
                            x + CONFIG.gridSize / 2,
                            y + CONFIG.gridSize / 2,
                            d,
                        );
                    }
                }

                p.save("daily_sketch.svg");

                // Cleanup: Remove the SVG element created by p5
                setTimeout(() => {
                    p.remove();
                }, 100);
            };
        };

        new p5(svgSketch);
    }

    // PNG Export
    async function exportPNG() {
        try {
            const canvas = await html2canvas(els.frame, {
                scale: 2,
                useCORS: true,
                backgroundColor: null,
            });

            const link = document.createElement("a");
            link.download = "daily_sketch.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
        } catch (err) {
            console.error("PNG Export failed", err);
        }
    }

    // Video Export (Composite)
    const btnRecord = document.getElementById("btn-record");
    let mediaRecorder;
    let chunks = [];
    let isRecording = false;
    let compositeInterval;

    btnRecord.addEventListener("click", () => {
        if (!isRecording) {
            startRecording();
        } else {
            stopRecording();
        }
    });

    async function startRecording() {
        const p5Canvas = document
            .getElementById("canvas-container")
            .querySelector("canvas");
        if (!p5Canvas) return;

        // 1. Hide dynamic elements to capture only static layout
        const originalTimeText = els.time.textContent;
        const originalTempText = els.temp.textContent;
        const originalWindText = els.wind.textContent;

        els.time.style.opacity = "0";
        els.temp.style.opacity = "0";
        els.wind.style.opacity = "0";

        // 2. Capture HTML Overlay (Static parts)
        const overlayEl = document.getElementById("html-overlay");
        const overlayCanvas = await html2canvas(overlayEl, {
            backgroundColor: null,
            scale: 1,
            width: CONFIG.width,
            height: CONFIG.height,
        });

        // Restore visibility
        els.time.style.opacity = "1";
        els.temp.style.opacity = "1";
        els.wind.style.opacity = "1";

        // 3. Prepare for dynamic text drawing
        // Get positions relative to the frame
        const getPos = (el) => {
            const rect = el.getBoundingClientRect();
            const frameRect = els.frame.getBoundingClientRect();
            const style = window.getComputedStyle(el);
            return {
                x: rect.left - frameRect.left,
                y: rect.top - frameRect.top,
                width: rect.width,
                height: rect.height,
                font: `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`,
                color: style.color,
                align: style.textAlign,
                baseline: "top", // standardizing
            };
        };

        const timePos = getPos(els.time);
        const tempPos = getPos(els.temp);
        const windPos = getPos(els.wind);

        // 4. Create composite canvas
        const compositeCanvas = document.createElement("canvas");
        compositeCanvas.width = CONFIG.width;
        compositeCanvas.height = CONFIG.height;
        const ctx = compositeCanvas.getContext("2d");

        // 5. Start Loop
        function drawComposite() {
            ctx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);

            // Draw p5
            ctx.drawImage(p5Canvas, 0, 0);

            // Draw Static Overlay
            ctx.drawImage(overlayCanvas, 0, 0);

            // Draw Dynamic Text
            // Note: We are approximating the mix-blend-mode 'difference' by using white text
            // over the black/white background. For perfect accuracy we'd need 'difference' composite mode
            // but that affects the whole layer stack.

            ctx.fillStyle = "white";
            ctx.globalCompositeOperation = "difference"; // Try to match CSS blend mode

            // Time
            ctx.font = timePos.font;
            ctx.textAlign = "right"; // Based on layout
            ctx.fillText(
                els.time.textContent,
                timePos.x + timePos.width,
                timePos.y + 18,
            ); // +18 for baseline adjustment approx

            // Temp
            ctx.font = tempPos.font;
            ctx.textAlign = "left";
            ctx.fillText(els.temp.textContent, tempPos.x, tempPos.y + 24);

            // Wind
            ctx.font = windPos.font;
            ctx.textAlign = "right";
            ctx.fillText(
                els.wind.textContent,
                windPos.x + windPos.width,
                windPos.y + 10,
            );

            ctx.globalCompositeOperation = "source-over"; // Reset
        }

        compositeInterval = setInterval(drawComposite, 1000 / 30);

        // 6. Record
        const stream = compositeCanvas.captureStream(30);
        mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm" });

        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) chunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
            clearInterval(compositeInterval);
            const blob = new Blob(chunks, { type: "video/webm" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "daily_sketch.webm";
            a.click();
            chunks = [];
        };

        mediaRecorder.start();
        isRecording = true;
        btnRecord.textContent = "Stop Recording";
        btnRecord.classList.add("bg-red-600", "text-white", "border-red-600");
        btnRecord.classList.remove("text-red-500");
    }

    function stopRecording() {
        mediaRecorder.stop();
        isRecording = false;
        btnRecord.textContent = "Record Video";
        btnRecord.classList.remove(
            "bg-red-600",
            "text-white",
            "border-red-600",
        );
        btnRecord.classList.add("text-red-500");
    }

    // --- INIT ---
    function init() {
        // 1. Start p5
        p5Instance = new p5(sketch, "canvas-container");

        // 2. Start Data Fetching
        fetchWeather();
        setInterval(fetchWeather, CONFIG.refreshRate);
        setInterval(updateTime, 1000);
        updateTime();

        // 3. Setup GUI
        const gui = new GUI();

        const f0 = gui.addFolder("Layout");
        f0.add(CONFIG, "width", 400, 2000).step(10).onChange(updateLayout);
        f0.add(CONFIG, "height", 400, 2000).step(10).onChange(updateLayout);

        const f1 = gui.addFolder("Sketch");
        f1.add(CONFIG, "gridSize", 5, 100).step(1);
        f1.add(CONFIG, "noiseScale", 0.001, 0.2);
        f1.add(CONFIG, "dotSize", 0.1, 2);
        f1.add(CONFIG, "animSpeed", 0, 0.1);
        f1.add(CONFIG, "isPaused");

        const f2 = gui.addFolder("Location");
        f2.add(CONFIG, "city").onFinishChange(() => {
            /* Todo: Geocode */
        });
        f2.add(CONFIG, "lat").onFinishChange(fetchWeather);
        f2.add(CONFIG, "lon").onFinishChange(fetchWeather);

        const f3 = gui.addFolder("Export");
        f3.add(CONFIG, "exportSize", ["current", "a4"]).name("SVG Size");

        // 4. Bind Buttons
        document
            .getElementById("btn-export-svg")
            .addEventListener("click", exportSVG);
        document
            .getElementById("btn-export-png")
            .addEventListener("click", exportPNG);
    }

    // Run
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
    } else {
        init();
    }
</script>
```
