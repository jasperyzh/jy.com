---
// src/pages/daily_sketch/251121-daily--mobile_camera.astro
import Layout from "@/layouts/Layout.astro";

/*
 * REMOVED FEATURES:
 * - Gallery preview button and all gallery-related functionality
 *
 * FUTURE IMPROVEMENTS (Not Implemented):
 * - Zoom Control: Pinch-to-zoom and slider using `zoom` capability
 * - Torch/Flash: Control device flash using `torch` constraint
 * - Grid Overlay: Rule-of-thirds grid overlay toggle
 * - Selfie Timer: Countdown timer (3s, 5s, 10s)
 * - Settings Panel: Collapsible settings for advanced options
 * - Video Quality Options: Resolution selector (720p, 1080p, 4K)
 * - Photo Quality: JPEG quality slider, PNG option
 * - Frame Rate Control: 30fps vs 60fps
 * - Burst Mode: Rapid photo capture
 * - Video Stabilization: Advanced constraints for stabilization
 * - White Balance: Auto/manual white balance control
 * - ISO Control: If device supports it
 */
---

<Layout title="Daily Sketch 251121 - Mobile Camera">
  <div class="relative h-screen w-full bg-neutral-900 overflow-hidden flex flex-col items-center justify-center text-white selection:bg-transparent">
    
    <!-- Video Feed (Viewfinder) -->
    <!-- playsinline is crucial for iOS to prevent auto-fullscreen -->
    <video 
      id="camera-feed" 
      autoplay 
      playsinline 
      muted 
      class="absolute inset-0 h-full w-full object-cover z-0 transform scale-x-[-1] data-[facing=environment]:scale-x-100 transition-transform"
    ></video>

    <!-- Hidden Canvas for capture -->
    <canvas id="capture-canvas" class="hidden"></canvas>

    <!-- Shutter Flash Effect -->
    <div id="shutter-flash" class="absolute inset-0 bg-white opacity-0 pointer-events-none z-20 transition-opacity duration-100"></div>

    <!-- UI Overlay -->
    <div class="absolute inset-0 z-10 flex flex-col justify-between p-6 pointer-events-none">
      
      <!-- Top Bar -->
      <div class="flex justify-between items-center w-full bg-gradient-to-b from-black/50 to-transparent pt-4 pb-8 px-2 pointer-events-auto">
        <div class="text-xs font-mono opacity-70">
          <span id="rec-indicator" class="hidden items-center gap-2 text-red-500 font-bold animate-pulse">
            <div class="w-3 h-3 rounded-full bg-red-500"></div> REC
            <span id="timer">00:00</span>
          </span>
          <span id="status-text">READY</span>
        </div>
        <div class="text-xs font-mono opacity-50">HD 30FPS</div>
      </div>

      <!-- Bottom Controls -->
      <div class="flex items-center justify-between w-full bg-gradient-to-t from-black/80 via-black/40 to-transparent pb-8 pt-12 px-4 pointer-events-auto">
        
        <!-- Left Side: Aspect Ratio Selector -->
        <div class="flex flex-col gap-2 items-center">
          <button id="aspect-ratio-btn" class="text-xs font-bold bg-neutral-800/50 px-2 py-1 rounded backdrop-blur">
            1:1
          </button>
        </div>

        <!-- Shutter / Record Button Container -->
        <div class="relative flex items-center justify-center">
           <!-- Photo Shutter -->
           <button id="shutter-btn" class="w-20 h-20 rounded-full border-4 border-white bg-white/20 backdrop-blur-sm flex items-center justify-center transition-all active:scale-95 hover:bg-white/30">
             <div class="w-16 h-16 rounded-full bg-white"></div>
           </button>

           <!-- Stop Record Button (Hidden by default) -->
           <button id="stop-btn" class="hidden w-20 h-20 rounded-full border-4 border-red-500 bg-red-500/20 backdrop-blur-sm items-center justify-center transition-all active:scale-95">
             <div class="w-8 h-8 rounded bg-red-500"></div>
           </button>
        </div>

        <!-- Right Side: Camera Flip / Mode Switch / Controls -->
        <div class="flex flex-col gap-4 items-center">
          <button id="flip-btn" class="w-12 h-12 rounded-full bg-neutral-800/50 backdrop-blur text-white flex items-center justify-center hover:bg-neutral-700/50 transition active:rotate-180 duration-300">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.5 2v6h-6"/><path d="m21.34 15.57a10 10 0 1 1-.57-8.38"/></svg>
          </button>

          <button id="mode-btn" class="text-xs font-bold bg-neutral-800/50 px-2 py-1 rounded backdrop-blur">
            PHOTO
          </button>
        </div>
      </div>

      <!-- Settings Panel (Collapsible) -->
      <div id="settings-panel" class="absolute bottom-0 left-0 right-0 bg-black/90 backdrop-blur-sm p-4 transform translate-y-full transition-transform duration-300 pointer-events-auto">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-sm font-mono uppercase">Settings</h3>
          <button id="close-settings" class="text-white">âœ•</button>
        </div>
        
        <!-- Focus Control -->
        <div id="focus-controls" class="mb-4 hidden">
          <label class="text-xs font-mono opacity-70 mb-2 block">Focus</label>
          <div class="flex gap-2 items-center">
            <button id="focus-mode-btn" class="text-xs bg-neutral-800 px-2 py-1 rounded">Auto</button>
            <span class="text-xs opacity-50">Tap video to focus</span>
          </div>
        </div>

        <!-- Exposure Control -->
        <div id="exposure-controls" class="mb-4 hidden">
          <label class="text-xs font-mono opacity-70 mb-2 block">Exposure</label>
          <div class="flex gap-2 items-center">
            <button id="exposure-mode-btn" class="text-xs bg-neutral-800 px-2 py-1 rounded">Auto</button>
            <input type="range" id="exposure-slider" class="flex-1" min="0" max="100" value="50" disabled />
            <span id="exposure-value" class="text-xs w-12 text-right">0</span>
          </div>
        </div>
      </div>

      <!-- Settings Toggle Button -->
      <button id="settings-btn" class="absolute top-4 right-4 w-10 h-10 rounded-full bg-neutral-800/50 backdrop-blur text-white flex items-center justify-center hover:bg-neutral-700/50 transition pointer-events-auto z-20">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6M5.64 5.64l4.24 4.24m4.24 4.24l4.24 4.24M1 12h6m6 0h6M5.64 18.36l4.24-4.24m4.24-4.24l4.24-4.24"/></svg>
      </button>

      <!-- Retry Button (Shown on errors) -->
      <button id="retry-btn" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-red-500/80 px-4 py-2 rounded text-sm font-mono hidden pointer-events-auto z-30">
        RETRY
      </button>

      <!-- Aspect Ratio Frame Overlay -->
      <div id="aspect-frame" class="absolute inset-0 z-5 pointer-events-none border-2 border-white/50"></div>

      <!-- Focus Indicator -->
      <div id="focus-indicator" class="absolute w-20 h-20 border-2 border-white rounded-full pointer-events-none opacity-0 transition-opacity duration-300 z-15"></div>
      </div>
    </div>

  </div>
</Layout>

<script>
  // State
  let stream: MediaStream | null = null;
  let mediaRecorder: MediaRecorder | null = null;
  let recordedChunks: Blob[] = [];
  let facingMode: 'user' | 'environment' = 'user';
  let isRecording = false;
  let mode: 'PHOTO' | 'VIDEO' = 'PHOTO';
  let timerInterval: ReturnType<typeof setInterval>;
  let videoTrack: MediaStreamTrack | null = null;
  let cameraCapabilities: MediaTrackCapabilities | null = null;
  let focusMode: 'auto' | 'manual' = 'auto';
  let exposureMode: 'auto' | 'manual' = 'auto';
  let exposureValue = 0;
  let aspectRatio: '1:1' | '4:3' | '16:9' | '3:4' | '9:16' = '1:1';
  let hasError = false;

  // Aspect ratio definitions
  const aspectRatios = {
    '1:1': { ratio: 1.0, label: '1:1' },
    '4:3': { ratio: 4/3, label: '4:3' },
    '16:9': { ratio: 16/9, label: '16:9' },
    '3:4': { ratio: 3/4, label: '3:4' },
    '9:16': { ratio: 9/16, label: '9:16' }
  };

  // Elements
  const video = document.getElementById('camera-feed') as HTMLVideoElement;
  const canvas = document.getElementById('capture-canvas') as HTMLCanvasElement;
  const shutterBtn = document.getElementById('shutter-btn') as HTMLButtonElement;
  const stopBtn = document.getElementById('stop-btn') as HTMLButtonElement;
  const flipBtn = document.getElementById('flip-btn') as HTMLButtonElement;
  const modeBtn = document.getElementById('mode-btn') as HTMLButtonElement;
  const shutterFlash = document.getElementById('shutter-flash') as HTMLDivElement;
  const statusText = document.getElementById('status-text') as HTMLSpanElement;
  const recIndicator = document.getElementById('rec-indicator') as HTMLDivElement;
  const timerDisplay = document.getElementById('timer') as HTMLSpanElement;
  const aspectRatioBtn = document.getElementById('aspect-ratio-btn') as HTMLButtonElement;
  const aspectFrame = document.getElementById('aspect-frame') as HTMLDivElement;
  const focusIndicator = document.getElementById('focus-indicator') as HTMLDivElement;
  const focusModeBtn = document.getElementById('focus-mode-btn') as HTMLButtonElement;
  const exposureModeBtn = document.getElementById('exposure-mode-btn') as HTMLButtonElement;
  const exposureSlider = document.getElementById('exposure-slider') as HTMLInputElement;
  const exposureValueDisplay = document.getElementById('exposure-value') as HTMLSpanElement;
  const focusControls = document.getElementById('focus-controls') as HTMLDivElement;
  const exposureControls = document.getElementById('exposure-controls') as HTMLDivElement;
  const settingsPanel = document.getElementById('settings-panel') as HTMLDivElement;
  const settingsBtn = document.getElementById('settings-btn') as HTMLButtonElement;
  const closeSettings = document.getElementById('close-settings') as HTMLButtonElement;
  const retryBtn = document.getElementById('retry-btn') as HTMLButtonElement;

  // --- Camera Capabilities Detection ---

  function detectCapabilities() {
    if (!videoTrack) return;
    
    try {
      cameraCapabilities = videoTrack.getCapabilities();
      const caps = cameraCapabilities as any; // Type assertion for experimental properties
      
      // Show/hide focus controls
      if (caps.focusMode && Array.isArray(caps.focusMode) && caps.focusMode.length > 0) {
        focusControls.classList.remove('hidden');
      } else {
        focusControls.classList.add('hidden');
      }
      
      // Show/hide exposure controls
      if (caps.exposureMode && Array.isArray(caps.exposureMode) && caps.exposureMode.length > 0) {
        exposureControls.classList.remove('hidden');
        if (caps.exposureCompensation) {
          const min = caps.exposureCompensation.min || -2;
          const max = caps.exposureCompensation.max || 2;
          exposureSlider.min = min.toString();
          exposureSlider.max = max.toString();
          exposureSlider.value = '0';
        }
      } else {
        exposureControls.classList.add('hidden');
      }
    } catch (e) {
      console.warn('Capabilities detection failed:', e);
    }
  }

  // --- Enhanced Error Handling ---

  function handleCameraError(err: Error) {
    hasError = true;
    console.error("Camera Error:", err);
    
    let errorMessage = "CAMERA ERROR";
    if (err.name === 'NotAllowedError') {
      errorMessage = "PERMISSION DENIED - Check browser settings";
    } else if (err.name === 'NotFoundError') {
      errorMessage = "NO CAMERA FOUND";
    } else if (err.name === 'OverconstrainedError') {
      errorMessage = "CAMERA LIMITATIONS";
    } else if (err.name === 'NotReadableError') {
      errorMessage = "CAMERA IN USE";
    }
    
    statusText.innerText = errorMessage;
    retryBtn.classList.remove('hidden');
    
    // Disable controls
    shutterBtn.disabled = true;
    flipBtn.disabled = true;
    modeBtn.disabled = true;
  }

  function clearError() {
    hasError = false;
    retryBtn.classList.add('hidden');
    shutterBtn.disabled = false;
    flipBtn.disabled = false;
    modeBtn.disabled = false;
  }

  // --- Core Camera Logic ---

  async function initCamera() {
    if (stream) {
      stream.getTracks().forEach(track => track.stop());
    }

    clearError();

    try {
      statusText.innerText = "INITIALIZING...";
      
      // Calculate aspect ratio constraints
      const aspectRatioValue = aspectRatios[aspectRatio].ratio;
      const constraints: MediaStreamConstraints = {
        video: {
          facingMode: facingMode,
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          aspectRatio: aspectRatioValue
        },
        audio: mode === 'VIDEO'
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      videoTrack = stream.getVideoTracks()[0];
      
      video.srcObject = stream;
      
      // Wait for video to be ready
      await new Promise((resolve) => {
        video.onloadedmetadata = resolve;
      });
      
      // Mirror effect handling
      if (facingMode === 'user') {
        video.classList.remove('scale-x-100'); 
        video.classList.add('scale-x-[-1]');
      } else {
        video.classList.remove('scale-x-[-1]');
        video.classList.add('scale-x-100');
      }

      // Detect capabilities
      detectCapabilities();
      
      // Update aspect ratio frame
      updateAspectFrame();
      
      statusText.innerText = mode;
    } catch (err) {
      handleCameraError(err as Error);
    }
  }

  // --- Photo Capture ---

  function takePhoto() {
    if (!stream || hasError) return;

    // Visual Flash
    shutterFlash.classList.remove('opacity-0');
    setTimeout(() => shutterFlash.classList.add('opacity-0'), 100);
    
    // Capture
    const context = canvas.getContext('2d');
    if (!context) return;

    const videoWidth = video.videoWidth;
    const videoHeight = video.videoHeight;
    const targetRatio = aspectRatios[aspectRatio].ratio;
    
    // Calculate crop dimensions to match aspect ratio
    let cropWidth = videoWidth;
    let cropHeight = videoHeight;
    let cropX = 0;
    let cropY = 0;
    
    const videoRatio = videoWidth / videoHeight;
    
    if (videoRatio > targetRatio) {
      // Video is wider than target - crop width
      cropHeight = videoHeight;
      cropWidth = videoHeight * targetRatio;
      cropX = (videoWidth - cropWidth) / 2;
      cropY = 0;
    } else {
      // Video is taller than target - crop height
      cropWidth = videoWidth;
      cropHeight = videoWidth / targetRatio;
      cropX = 0;
      cropY = (videoHeight - cropHeight) / 2;
    }
    
    // Set canvas to target aspect ratio size
    canvas.width = cropWidth;
    canvas.height = cropHeight;
    
    // Handle mirroring for user-facing camera capture
    if (facingMode === 'user') {
      context.translate(canvas.width, 0);
      context.scale(-1, 1);
    }

    // Draw cropped region
    context.drawImage(
      video,
      cropX, cropY, cropWidth, cropHeight,
      0, 0, canvas.width, canvas.height
    );
    
    const dataUrl = canvas.toDataURL('image/jpeg');
    saveMedia(dataUrl, 'photo');
  }

  // --- Video Recording ---

  function startRecording() {
    if (!stream) return;
    recordedChunks = [];
    
    const options = { mimeType: 'video/webm;codecs=vp9' };
    // Fallback for Safari/Others
    const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') 
      ? 'video/webm;codecs=vp9' 
      : 'video/webm';

    try {
      mediaRecorder = new MediaRecorder(stream, { mimeType });
    } catch (e) {
      mediaRecorder = new MediaRecorder(stream); // Fallback to default
    }

    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        recordedChunks.push(event.data);
      }
    };

    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      saveMedia(url, 'video');
    };

    mediaRecorder.start();
    isRecording = true;
    updateUIState();
    startTimer();
  }

  function stopRecording() {
    if (mediaRecorder && isRecording) {
      mediaRecorder.stop();
      isRecording = false;
      updateUIState();
      stopTimer();
    }
  }

  // --- Helper Functions ---

  function saveMedia(url: string, type: 'photo' | 'video') {
    const a = document.createElement('a');
    a.href = url;
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    a.download = `cam-${timestamp}.${type === 'photo' ? 'jpg' : 'webm'}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    statusText.innerText = "SAVED TO DEVICE";
    setTimeout(() => statusText.innerText = mode, 2000);
  }

  // --- Aspect Ratio Frame Overlay ---

  function updateAspectFrame() {
    if (!video || !aspectFrame) return;
    
    const container = video.parentElement;
    if (!container) return;
    
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    const targetRatio = aspectRatios[aspectRatio].ratio;
    const containerRatio = containerWidth / containerHeight;
    
    let frameWidth = containerWidth;
    let frameHeight = containerHeight;
    let frameLeft = 0;
    let frameTop = 0;
    
    if (containerRatio > targetRatio) {
      // Container is wider - fit to height
      frameHeight = containerHeight;
      frameWidth = containerHeight * targetRatio;
      frameLeft = (containerWidth - frameWidth) / 2;
      frameTop = 0;
    } else {
      // Container is taller - fit to width
      frameWidth = containerWidth;
      frameHeight = containerWidth / targetRatio;
      frameLeft = 0;
      frameTop = (containerHeight - frameHeight) / 2;
    }
    
    aspectFrame.style.width = `${frameWidth}px`;
    aspectFrame.style.height = `${frameHeight}px`;
    aspectFrame.style.left = `${frameLeft}px`;
    aspectFrame.style.top = `${frameTop}px`;
  }

  // --- Focus Control ---

  async function setFocusPoint(x: number, y: number) {
    if (!videoTrack || focusMode === 'auto' || !cameraCapabilities) return;
    
    try {
      // Normalize coordinates (0-1)
      const rect = video.getBoundingClientRect();
      const normalizedX = (x - rect.left) / rect.width;
      const normalizedY = (y - rect.top) / rect.height;
      
      // Clamp to 0-1
      const clampedX = Math.max(0, Math.min(1, normalizedX));
      const clampedY = Math.max(0, Math.min(1, normalizedY));
      
      await videoTrack.applyConstraints({
        advanced: [{
          pointsOfInterest: [{ x: clampedX, y: clampedY }]
        }] as any // Type assertion for experimental property
      });
      
      // Show focus indicator
      focusIndicator.style.left = `${x - 40}px`;
      focusIndicator.style.top = `${y - 40}px`;
      focusIndicator.classList.remove('opacity-0');
      focusIndicator.classList.add('opacity-100');
      
      setTimeout(() => {
        focusIndicator.classList.remove('opacity-100');
        focusIndicator.classList.add('opacity-0');
      }, 1000);
    } catch (e) {
      console.warn('Focus point setting failed:', e);
    }
  }

  async function setFocusMode(mode: 'auto' | 'manual') {
    if (!videoTrack || !cameraCapabilities) return;
    
    focusMode = mode;
    focusModeBtn.textContent = mode === 'auto' ? 'Auto' : 'Manual';
    
    try {
      await videoTrack.applyConstraints({
        focusMode: mode
      } as any); // Type assertion for experimental property
    } catch (e) {
      console.warn('Focus mode setting failed:', e);
    }
  }

  // --- Exposure Control ---

  async function setExposureMode(mode: 'auto' | 'manual') {
    if (!videoTrack || !cameraCapabilities) return;
    
    exposureMode = mode;
    exposureModeBtn.textContent = mode === 'auto' ? 'Auto' : 'Manual';
    exposureSlider.disabled = mode === 'auto';
    
    try {
      await videoTrack.applyConstraints({
        exposureMode: mode
      } as any); // Type assertion for experimental property
    } catch (e) {
      console.warn('Exposure mode setting failed:', e);
    }
  }

  async function setExposureCompensation(value: number) {
    if (!videoTrack || exposureMode === 'auto') return;
    
    exposureValue = value;
    if (exposureValueDisplay) {
      exposureValueDisplay.textContent = value.toFixed(1);
    }
    
    try {
      await videoTrack.applyConstraints({
        exposureCompensation: value
      } as any); // Type assertion for experimental property
    } catch (e) {
      console.warn('Exposure compensation setting failed:', e);
    }
  }

  function updateUIState() {
    if (isRecording) {
      shutterBtn.classList.add('hidden');
      stopBtn.classList.remove('hidden');
      stopBtn.classList.add('flex');
      recIndicator.classList.remove('hidden');
      recIndicator.classList.add('flex');
      flipBtn.disabled = true;
      flipBtn.classList.add('opacity-50');
      modeBtn.classList.add('opacity-50');
    } else {
      shutterBtn.classList.remove('hidden');
      stopBtn.classList.add('hidden');
      stopBtn.classList.remove('flex');
      recIndicator.classList.add('hidden');
      recIndicator.classList.remove('flex');
      flipBtn.disabled = false;
      flipBtn.classList.remove('opacity-50');
      modeBtn.classList.remove('opacity-50');
    }
  }

  // Timer logic
  let seconds = 0;
  function startTimer() {
    seconds = 0;
    timerDisplay.innerText = "00:00";
    timerInterval = setInterval(() => {
      seconds++;
      const m = Math.floor(seconds / 60).toString().padStart(2, '0');
      const s = (seconds % 60).toString().padStart(2, '0');
      timerDisplay.innerText = `${m}:${s}`;
    }, 1000);
  }

  function stopTimer() {
    clearInterval(timerInterval);
    timerDisplay.innerText = "00:00";
  }

  // --- Event Listeners ---

  shutterBtn.addEventListener('click', () => {
    if (hasError) return;
    if (mode === 'PHOTO') {
      takePhoto();
    } else {
      startRecording();
    }
  });

  stopBtn.addEventListener('click', stopRecording);

  flipBtn.addEventListener('click', () => {
    if (hasError) return;
    facingMode = facingMode === 'user' ? 'environment' : 'user';
    initCamera();
  });

  modeBtn.addEventListener('click', () => {
    if(isRecording || hasError) return;
    mode = mode === 'PHOTO' ? 'VIDEO' : 'PHOTO';
    modeBtn.innerText = mode;
    
    // Visual update of shutter button
    if(mode === 'VIDEO') {
      const inner = shutterBtn.firstElementChild;
      inner?.classList.remove('bg-white');
      inner?.classList.add('bg-red-500');
    } else {
      const inner = shutterBtn.firstElementChild;
      inner?.classList.remove('bg-red-500');
      inner?.classList.add('bg-white');
    }
    
    // Re-init camera because video might need audio permission
    initCamera();
  });

  // Aspect ratio selector
  const aspectRatioList: Array<'1:1' | '4:3' | '16:9' | '3:4' | '9:16'> = ['1:1', '4:3', '16:9', '3:4', '9:16'];
  let aspectRatioIndex = 0;
  
  aspectRatioBtn.addEventListener('click', () => {
    if (hasError) return;
    aspectRatioIndex = (aspectRatioIndex + 1) % aspectRatioList.length;
    aspectRatio = aspectRatioList[aspectRatioIndex];
    aspectRatioBtn.textContent = aspectRatio;
    initCamera();
  });

  // Touch/Click to focus
  video.addEventListener('click', (e) => {
    if (focusMode === 'manual' && !hasError) {
      setFocusPoint(e.clientX, e.clientY);
    }
  });

  video.addEventListener('touchend', (e) => {
    if (focusMode === 'manual' && !hasError && e.touches.length === 0) {
      const touch = e.changedTouches[0];
      setFocusPoint(touch.clientX, touch.clientY);
    }
  });

  // Focus mode toggle
  focusModeBtn.addEventListener('click', () => {
    const newMode = focusMode === 'auto' ? 'manual' : 'auto';
    setFocusMode(newMode);
  });

  // Exposure mode toggle
  exposureModeBtn.addEventListener('click', () => {
    const newMode = exposureMode === 'auto' ? 'manual' : 'auto';
    setExposureMode(newMode);
  });

  // Exposure slider
  exposureSlider.addEventListener('input', (e) => {
    const value = parseFloat((e.target as HTMLInputElement).value);
    setExposureCompensation(value);
  });

  // Settings panel toggle
  settingsBtn.addEventListener('click', () => {
    settingsPanel.classList.remove('translate-y-full');
  });

  closeSettings.addEventListener('click', () => {
    settingsPanel.classList.add('translate-y-full');
  });

  // Retry button
  retryBtn.addEventListener('click', () => {
    initCamera();
  });

  // Window resize handler for aspect frame
  window.addEventListener('resize', () => {
    updateAspectFrame();
  });

  // Initialize
  window.addEventListener('DOMContentLoaded', () => {
    initCamera();
    updateAspectFrame();
  });

  // Cleanup on leave
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') {
        if(stream) {
            stream.getTracks().forEach(t => t.stop());
        }
    } else {
        initCamera();
    }
  });
</script>