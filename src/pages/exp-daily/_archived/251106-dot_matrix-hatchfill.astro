---
import Layout from "@/layouts/Layout.astro";
---

<Layout title="Dot Matrix Base">
  <main class="container">
    <div class="header">
      <h1>Dot Matrix Perlin Noise</h1>
      <p>
        Animated grayscale Perlin noise on a simulated 128x64 dot matrix
        display.
      </p>
    </div>
    <div id="canvas-container"></div>
    <div class="CONTROL-grid"></div>
  </main>
</Layout>

<script is:inline type="module">
  import "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js";
  import "https://cdn.jsdelivr.net/npm/p5.js-svg@1.5.1/dist/p5.svg.min.js";
</script>
<script is:inline type="module">
  import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";
  import PixelDisplay from "/dailies/PixelDisplay.js";
  import HatchFill from "/dailies/HatchFill.js";

  const GR__ = 1.618;
  const MATRIX_SIZES = [64, 32, 16, 8, 4];
  let PIXEL_SCALE;
  let PIXEL_GAP;
  let MATRIX_WIDTH;
  let MATRIX_HEIGHT;

  // todo--
  // - [ ] transform the scale of each dots according to data

  let display;
  let zOffset = 0;

  const colorThemes = {
    "2a": { off: [13, 13, 13], on: [204, 165, 69], stroke: [13, 13, 13] },
    milk: { off: [227, 237, 239], on: [13, 13, 13], stroke: [13, 13, 13] },
    green: { off: [13, 13, 13], on: [100, 255, 100], stroke: [150, 255, 150] },
    amber: { off: [40, 20, 0], on: [255, 180, 0], stroke: [255, 200, 100] },
    white: { off: [40, 40, 40], on: [220, 220, 220], stroke: [255, 255, 255] },
    blue: { off: [10, 20, 40], on: [80, 160, 255], stroke: [120, 180, 255] },
  };

  const CONTROL = {
    matrixSize: 4,
    theme: "milk",
    noiseScale: 0.05,
    animationSpeed: 0.002,
    shadeSteps: 2,
    dotScaleFactor: 1.0, // New control for dot scaling
    dotNoiseInfluence: 1.0, // New control for dot size influence by noise
    useColorThemeShading: false, // New control for color theme shading
    useHatchFill: false, // Toggle hatch fill for performance
    hatchDensity: 0.05, // Spacing between lines (0.01-1.0, smaller = denser)
    hatchAngle: 45, // Angle of hatch lines in degrees (0-180)
    hatchCrossHatch: false, // Enable cross-hatching
    hatchUseGlobalDensity: true, // Use fixed pixel spacing instead of relative to shape size
    hatchGlobalSpacing: 3, // Fixed pixel spacing when useGlobalDensity is true
    isAnimationPaused: false,
    logOledData: () => logOledData(),
    exportSvg: () => exportSvg(),
  };

  function resetSketch() {
    MATRIX_WIDTH = Number(CONTROL.matrixSize);
    MATRIX_HEIGHT = Number(CONTROL.matrixSize);
    PIXEL_SCALE = 512 / MATRIX_WIDTH;
    PIXEL_GAP = PIXEL_SCALE - PIXEL_SCALE / Math.pow(GR__, 1);

    resizeCanvas(
      MATRIX_WIDTH * PIXEL_SCALE,
      MATRIX_HEIGHT * PIXEL_SCALE
    );

    display = new PixelDisplay(
      MATRIX_WIDTH,
      MATRIX_HEIGHT,
      PIXEL_SCALE,
      PIXEL_GAP
    );
    updateColorTheme();
  }

  window.setup = function () {
    MATRIX_WIDTH = Number(CONTROL.matrixSize);
    MATRIX_HEIGHT = Number(CONTROL.matrixSize);
    PIXEL_SCALE = 512 / MATRIX_WIDTH;
    PIXEL_GAP = PIXEL_SCALE - PIXEL_SCALE / Math.pow(GR__, 0);

    const canvas = createCanvas(
      MATRIX_WIDTH * PIXEL_SCALE,
      MATRIX_HEIGHT * PIXEL_SCALE
    );
    canvas.parent("canvas-container");

    display = new PixelDisplay(
      MATRIX_WIDTH,
      MATRIX_HEIGHT,
      PIXEL_SCALE,
      PIXEL_GAP
    );
    updateColorTheme();

    const gui = new GUI();
    gui.add(CONTROL, 'matrixSize', MATRIX_SIZES).name('Matrix Size').onChange(resetSketch);
    gui
      .add(CONTROL, "theme", Object.keys(colorThemes))
      .name("Theme")
      .onChange(updateColorTheme);
    gui.add(CONTROL, "noiseScale", 0.01, 0.8, 0.005).name("Noise Scale");
    gui.add(CONTROL, "animationSpeed", 0, 0.05, 0.001).name("Animation Speed");
    gui.add(CONTROL, "shadeSteps", 2, 16, 1).name("Shade Steps");
    gui.add(CONTROL, "dotScaleFactor", 0.1, 5.0, 0.05).name("Dot Scale Factor");
    gui.add(CONTROL, "dotNoiseInfluence", 0.0, 3.0, 0.05).name("Dot Noise Influence");
    gui.add(CONTROL, "useColorThemeShading").name("Use Color Theme Shading");
    
    // Hatch fill controls
    const hatchFolder = gui.addFolder("Hatch Fill");
    hatchFolder.add(CONTROL, "useHatchFill").name("Use Hatch Fill");
    hatchFolder.add(CONTROL, "hatchUseGlobalDensity").name("Use Global Density");
    hatchFolder.add(CONTROL, "hatchDensity", 0.01, 1.0, 0.01).name("Hatch Density");
    hatchFolder.add(CONTROL, "hatchGlobalSpacing", 1, 20, 0.5).name("Global Spacing (px)");
    hatchFolder.add(CONTROL, "hatchAngle", 0, 180, 1).name("Hatch Angle");
    hatchFolder.add(CONTROL, "hatchCrossHatch").name("Cross Hatch");
    
    gui
      .add(CONTROL, "isAnimationPaused")
      .name("Pause Animation")
      .onChange(toggleAnimation);
    gui.add(CONTROL, "logOledData").name("Log OLED Data");
    gui.add(CONTROL, "exportSvg").name("Export SVG");
  };

  window.draw = function () {
    background(colorThemes[CONTROL.theme].off);

    push();
    translate(1, 1);
    display.clear();

    for (let y = 0; y < display.matrixHeight; y++) {
      for (let x = 0; x < display.matrixWidth; x++) {
        const noiseVal = noise(
          x * CONTROL.noiseScale,
          y * CONTROL.noiseScale,
          zOffset
        );
        display.setPixel(x, y, noiseVal);
      }
    }

    zOffset += CONTROL.animationSpeed;
    
    if (CONTROL.useHatchFill) {
      // Render with hatch fill
      renderHatchFill();
    } else {
      // Render with solid fill
      display.render(0, 0, CONTROL);
    }
    pop();
  };

  function renderHatchFill() {
    // Create hatch fill instance
    const hatchFill = new HatchFill({
      density: CONTROL.hatchDensity,
      angle: CONTROL.hatchAngle,
      crossHatch: CONTROL.hatchCrossHatch,
      useGlobalDensity: CONTROL.hatchUseGlobalDensity,
      globalSpacing: CONTROL.hatchGlobalSpacing,
    });

    // Set stroke color and no fill
    stroke(display.colorOn);
    strokeWeight(1);
    noFill();

    let totalLinesDrawn = 0;
    let shapesWithLines = 0;

    // Render each pixel with hatch fill
    for (let x = 0; x < display.matrixWidth; x++) {
      for (let y = 0; y < display.matrixHeight; y++) {
        const noiseVal = display.pixelMatrix[x][y];
        if (noiseVal === 0) continue;

        // Calculate dot position and size (matching display.render logic)
        const baseDotSize = display.pixelScale - display.pixelGap;
        const maxDotSize = baseDotSize * CONTROL.dotScaleFactor;
        const minDotSize = lerp(maxDotSize, 0, CONTROL.dotNoiseInfluence);
        const scaledDotSize = map(noiseVal, 0, 1, minDotSize, maxDotSize);
        const offset = (display.pixelScale - scaledDotSize) / 2;

        // Calculate center position (coordinates are already translated by push/translate)
        const cx = x * display.pixelScale + offset + scaledDotSize / 2;
        const cy = y * display.pixelScale + offset + scaledDotSize / 2;
        const radius = scaledDotSize / 2;

        // Skip if radius is too small
        if (radius < 0.5) continue;

        // Generate hatch lines for this circle
        const hatchLines = hatchFill.fillCircle(cx, cy, radius);

        // Draw hatch lines
        if (hatchLines && hatchLines.length > 0) {
          shapesWithLines++;
          for (const lineSeg of hatchLines) {
            if (lineSeg && lineSeg.x1 !== undefined && lineSeg.y1 !== undefined && 
                lineSeg.x2 !== undefined && lineSeg.y2 !== undefined) {
              // Draw line (coordinates are already in the translated space)
              line(lineSeg.x1, lineSeg.y1, lineSeg.x2, lineSeg.y2);
              totalLinesDrawn++;
            }
          }
        }
      }
    }
    
    // Debug output (only log once per second to avoid spam)
    if (frameCount % 60 === 0) {
      console.log(`Hatch fill: ${shapesWithLines} shapes, ${totalLinesDrawn} lines drawn`);
    }
  }

  function updateColorTheme() {
    const theme = colorThemes[CONTROL.theme];
    display.setColors(
      color(...theme.off),
      color(...theme.on),
      color(...theme.stroke)
    );
  }

  function toggleAnimation() {
    if (CONTROL.isAnimationPaused) {
      noLoop();
    } else {
      loop();
    }
  }

  function logOledData() {
    const pageCount = display.matrixHeight / 8;
    const bufferSize = display.matrixWidth * pageCount;
    const oledBuffer = new Uint8Array(bufferSize);

    for (let page = 0; page < pageCount; page++) {
      for (let x = 0; x < display.matrixWidth; x++) {
        let byte = 0;
        for (let bit = 0; bit < 8; bit++) {
          const y = page * 8 + bit;
          if (display.pixelMatrix[x][y] > 0) {
            byte |= 1 << bit;
          }
        }
        oledBuffer[page * display.matrixWidth + x] = byte;
      }
    }
    console.log(`SH1106-compatible data buffer (threshold > 0):`, oledBuffer);
  }

  function exportSvg() {
    const svgRenderer = (p) => {
      p.setup = () => {
        p.createCanvas(
          display.matrixWidth * display.pixelScale,
          display.matrixHeight * display.pixelScale,
          p.SVG
        );
        p.noLoop();
        p.background(display.colorOff);

        if (CONTROL.useHatchFill) {
          // Export with hatch fill
          const hatchFill = new HatchFill({
            density: CONTROL.hatchDensity,
            angle: CONTROL.hatchAngle,
            crossHatch: CONTROL.hatchCrossHatch,
            useGlobalDensity: CONTROL.hatchUseGlobalDensity,
            globalSpacing: CONTROL.hatchGlobalSpacing,
          });

          p.stroke(display.colorOn);
          p.strokeWeight(1);
          p.noFill();

          for (let x = 0; x < display.matrixWidth; x++) {
            for (let y = 0; y < display.matrixHeight; y++) {
              const noiseVal = display.pixelMatrix[x][y];
              if (noiseVal === 0) continue;

              // Calculate dot position and size
              const baseDotSize = display.pixelScale - display.pixelGap;
              const maxDotSize = baseDotSize * CONTROL.dotScaleFactor;
              const minDotSize = lerp(maxDotSize, 0, CONTROL.dotNoiseInfluence);
              const scaledDotSize = map(noiseVal, 0, 1, minDotSize, maxDotSize);
              const offset = (display.pixelScale - scaledDotSize) / 2;

              const cx = x * display.pixelScale + offset + scaledDotSize / 2;
              const cy = y * display.pixelScale + offset + scaledDotSize / 2;
              const radius = scaledDotSize / 2;

              // Generate hatch lines for this circle
              const hatchLines = hatchFill.fillCircle(cx, cy, radius);

              // Draw hatch lines as SVG
              for (const lineSeg of hatchLines) {
                if (lineSeg && lineSeg.x1 !== undefined && lineSeg.y1 !== undefined && 
                    lineSeg.x2 !== undefined && lineSeg.y2 !== undefined) {
                  p.line(lineSeg.x1, lineSeg.y1, lineSeg.x2, lineSeg.y2);
                }
              }
            }
          }
        } else {
          // Export with solid fill
          p.noStroke();

          for (let x = 0; x < display.matrixWidth; x++) {
            for (let y = 0; y < display.matrixHeight; y++) {
              const noiseVal = display.pixelMatrix[x][y];
              if (noiseVal === 0) continue;

              let pixelColor;
              if (!CONTROL.useColorThemeShading) {
                pixelColor = display.colorOn;
              } else {
                const shadeValue = floor(map(noiseVal, 0, 1, 0, CONTROL.shadeSteps));
                if (shadeValue === 0) continue;
                const amount = (shadeValue) / (CONTROL.shadeSteps - 1);
                pixelColor = lerpColor(
                  display.colorOff,
                  display.colorOn,
                  amount
                );
              }

              p.fill(pixelColor);

              const baseDotSize = display.pixelScale - display.pixelGap;
              const maxDotSize = baseDotSize * CONTROL.dotScaleFactor;
              const minDotSize = lerp(maxDotSize, 0, CONTROL.dotNoiseInfluence);
              const scaledDotSize = map(noiseVal, 0, 1, minDotSize, maxDotSize);
              const offset = (display.pixelScale - scaledDotSize) / 2;

              p.ellipseMode(CORNER);
              p.ellipse(
                x * display.pixelScale + offset,
                y * display.pixelScale + offset,
                scaledDotSize,
                scaledDotSize
              );
            }
          }
        }
        p.save("dot-matrix-perlin-noise.svg");
      };
    };
    new p5(svgRenderer);
  }
</script>
